<!--
  File automatically created
  Command used:
  # release: 2.3.0 Jun 23 2013-08:06:07
  admsXml \
   -e ./qucsVersion.xml \
   -e ./qucsMODULEcore.xml
-->


<?escript name=".adms.implicit.xml" ?>
<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- built-in implicit transforms @SVN_VERSION=Unversioned directory@ -->
<!-- this file is saved in local working directory, then downloaded prior any -e xml files -->
<!-- unless flag '-x' is specified -->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/adms/admst.xml">

<admst:variable name="globalmodule"/>
<admst:variable name="globalassignment"/>
<admst:variable name="globalcontribution"/>
<admst:variable name="globalexpression"/>
<admst:variable name="globalopdependent" string="no"/>
<admst:variable name="globalpartitionning"/>
<admst:variable name="globaltreenode"/>

<admst:template match="e:dependency">
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:variable name="globalexpression" path="."/>
      <admst:apply-templates select="tree" match="e:dependency"/>
      <admst:variable name="globalexpression"/>
      <admst:value-to select="dependency" path="tree/dependency"/>
      <admst:value-to select="dependency[.='constant' and $globalopdependent='yes']" string="noprobe"/>
      <admst:choose>
        <admst:when test="[nilled($globalpartitionning)]">
          <admst:value-to select="variable/usedinevaluate" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_model']">
          <admst:value-to select="variable/usedinmodel" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_instance']">
          <admst:value-to select="variable/usedininstance" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_step']">
          <admst:value-to select="variable/usedininitial_step" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='noise']">
          <admst:value-to select="variable/usedinnoise" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='final_step']">
          <admst:value-to select="variable/usedinfinal" string="yes"/>
        </admst:when>
      </admst:choose>
      <admst:reverse select="function"/>
      <admst:value-to select="math/value" path="tree/math/value"/>
    </admst:when>
    <admst:when test="[datatypename='probe']">
      <admst:value-to select="dependency" string="linear"/>
      <admst:push into="$globalexpression/probe" select="." onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='array']">
      <admst:apply-templates select="variable" match="e:dependency"/>
      <admst:value-to select="dependency" path="variable/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='variable']">
      <admst:push into="$globalexpression/probe" select="probe" onduplicate="ignore"/>
      <admst:push into="$globalexpression/variable" select="." onduplicate="ignore"/>
      <admst:push into="$globaltreenode/@variable" select="." onduplicate="ignore"/>
      <admst:value-to select="dependency" path="prototype/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="e:dependency"/>
      <admst:value-to select="dependency" path="arg1/dependency"/>
      <admst:value-to select="[name='minus']/math/value" string="-%(arg1/math/value)"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="e:dependency"/>
      <!--
        +:             -:            *:            /:                                                          
          c  np l  nl    c  np l  nl   c  np l  nl   c  np nl nl                                                          
          np np l  nl    np np l  nl   np np l  nl   np np nl nl                                                          
          l  l  l  nl    l  l  l  nl   l  l  nl nl   l  l  nl nl                                                          
          nl nl nl nl    nl nl nl nl   nl nl nl nl   nl nl nl nl                                                          
      -->
      <admst:choose>
        <admst:when test="[arg1/dependency='nonlinear' or arg2/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[name='multtime' and (arg1|arg2)/dependency=('linear'|'linear')]">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[name='multdiv' and arg2/dependency='linear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[arg1/dependency='linear' or arg2/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[arg1/dependency='noprobe' or arg2/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="e:dependency"/>
      <!--
          ?: - arg1=c -  - arg1!=c -                                                            
             c  np l  nl np np l  nl                                                             
             np np l  nl np np l  nl                                                             
             l  l  l  nl l  l  l  nl                                                             
             nl nl nl nl nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[arg2/dependency='nonlinear' or arg3/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[arg2/dependency='linear' or arg3/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[arg1/dependency!='constant' or arg2/dependency='noprobe' or arg3/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='ddx' or name='\$ddx' or name='\$derivate']">
          <admst:value-to select="$globalassignment/lhs/derivate" string="yes"/>
          <admst:apply-templates select="arguments[1]" match="e:dependency"/>
          <admst:push into="$globalexpression/variable/ddxprobe" select="arguments[2]" onduplicate="ignore"/>
          <admst:choose>
            <admst:when test="arguments[1]/dependency[.='constant' or .='noprobe']">
              <admst:value-to select="dependency" path="arguments[1]/dependency"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arguments" match="e:dependency"/>
          <admst:choose>
            <admst:when test="[(name='ddt' or name='\$ddt')or(name='idt' or name='\$idt')]">
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:when>
            <admst:when test="arguments/dependency[.='linear' or .='nonlinear']">
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:when>
            <admst:when test="arguments/dependency[.='noprobe']">
              <admst:value-to select="dependency" string="noprobe"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="dependency" string="constant"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:value-to test="dependency[.='linear' or .='nonlinear']" select="$globalexpression/hasVoltageDependentFunction" string="yes"/>
      <admst:value-to select="subexpression/expression" path="$globalexpression"/>
      <!-- fixme: these flags should be set after all contribs are transformed to ...<+F(...); canonical form -->
      <admst:value-to test="[name='ddt']" select="$globalcontribution/#fixmedynamic" path="1"/>
      <admst:value-to test="[name='white_noise']" select="$globalcontribution/#fixmewhitenoise" path="1"/>
      <admst:value-to test="[name='flicker_noise']" select="$globalcontribution/#fixmeflickernoise" path="1"/>
      <admst:value-to test="[name='\$temperature']" select="$globalassignment/lhs/TemperatureDependent" string="yes"/>
      <admst:choose>
        <admst:when test="[name='\$temperature' or name='\$vt' or name='idt' or name='ddt' or
                           name='\$param_given' or name='\$given' or name='ddx' or name='flicker_noise' or name='white_noise']"/>
        <admst:when
          test="[name='analysis' or name='\$analysis' or name='\$simparam' or name='simparam' or
          name='\$shrinka' or name='\$shrinkl' or name='\$limexp' or
          name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or
          name='hypot' or name='limexp' or name='ln' or name='log' or name='max' or name='min' or name='pow' or
          name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh' or name='floor' or name='ceil']">
          <admst:push into="$globalexpression/function" select="."/>
          <admst:value-to select="class" string="builtin"/>
        </admst:when>
        <admst:otherwise>
          <admst:assert test="[exists(definition)]" format="%(lexval/(f|':'|l|':'|c)): analog function '%(name)' is undefined\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-to select="math/value" path="value"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:value-to select="math/value" string="%(value)e+18"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:value-to select="math/value" string="%(value)e+15"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-to select="math/value" string="%(value)e+12"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-to select="math/value" string="%(value)e+9"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-to select="math/value" string="%(value)e+6"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-to select="math/value" string="%(value)e+3"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-to select="math/value" string="%(value)e+2"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-to select="math/value" string="%(value)e+1"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:value-to select="math/value" string="%(value)e-1"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-to select="math/value" string="%(value)e-2"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-to select="math/value" string="%(value)e-3"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-to select="math/value" string="%(value)e-6"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-to select="math/value" string="%(value)e-9"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:value-to select="math/value" string="%(value)e-10"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-to select="math/value" string="%(value)e-12"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-to select="math/value" string="%(value)e-15"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-to select="math/value" string="%(value)e-18"/>
        </admst:when>
        <admst:otherwise>
          <admst:error format="%(lexval/(f|':'|l|':'|c)): unit not supported: %(scalingunit)\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='string']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="dependency">
  <admst:choose>
    <admst:when test="[datatypename='callfunction']">
      <admst:apply-templates select="function/arguments" match="e:dependency"/>
      <admst:value-to select="dependency" path="function/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <!--
        w, logic(D,while.d)            , d=wb.d                                               
              c                 !c                           
           c  wb,w,!c?(D,wb,!D) D,wb,!D                                                                                        
           !c wb                wb                                                                                             
      -->
      <admst:apply-templates select="while" match="e:dependency"/>
      <admst:apply-templates select="[$globalopdependent='yes' or while/dependency='constant']/whileblock" match="dependency"/>
      <admst:if test="[$globalopdependent='no']">
        <admst:apply-templates select="while[dependency='constant']" match="e:dependency"/>
        <admst:if test="[while/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="whileblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:if>
      </admst:if>
      <!--
          wl:  w=c          w!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[whileblock/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[whileblock/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[while/dependency!='constant' or whileblock/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='forloop']">
      <admst:apply-templates select="initial|update" match="dependency"/>
      <admst:apply-templates select="condition" match="e:dependency"/>
      <admst:apply-templates select="[$globalopdependent='yes' or nilled((initial|condition|update)/[dependency!='constant'])]/forblock" match="dependency"/>
      <admst:if test="[$globalopdependent='no']">
        <admst:apply-templates select="(initial|update)/[dependency='constant']" match="dependency"/>
        <admst:apply-templates select="condition[dependency='constant']" match="e:dependency"/>
        <admst:if test="[condition/dependency!='constant' or initial/dependency!='constant' or update/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="forblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:if>
      </admst:if>
      <!--
          fl:  f=c          f!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[forblock/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[forblock/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[(condition!='constant' or initial!='constant' or update!='constant') or forblock/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:variable name="globaltreenode" path="case"/>
      <admst:apply-templates select="case" match="e:dependency"/>
      <admst:variable name="globaltreenode"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:variable name="globaltreenode" path="."/>
          <admst:apply-templates select="." match="e:dependency"/>
          <admst:variable name="globaltreenode"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="dependency"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:push into="$globalmodule/conditional" select="."/>
      <admst:apply-templates select="if" match="e:dependency"/>
      <admst:choose>
        <admst:when test="[$globalopdependent='no' and if/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="then|else" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="then|else" match="dependency"/>
        </admst:otherwise>
      </admst:choose>
      <!--
          cd:  i=c          i!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[then/dependency='nonlinear' or else/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[then/dependency='linear' or else/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[if/dependency!='constant' or then/dependency='noprobe' or else/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:variable name="globalcontribution" path="."/>
      <admst:apply-templates select="rhs" match="e:dependency"/>
      <admst:variable name="globalcontribution"/>
      <admst:push into="lhs/probe" select="rhs/probe" onduplicate="ignore"/>
      <admst:value-to select="dependency" string="nonlinear"/>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <admst:choose>
        <admst:when test="[lhs/datatypename='array']">
          <admst:variable name="lhs" path="lhs/variable"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="lhs" path="lhs"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[$globalpartitionning='initial_model']">
          <admst:value-to select="$lhs/setinmodel" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_instance']">
          <admst:value-to select="$lhs/setininstance" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_step']">
          <admst:value-to select="$lhs/setininitial_step" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='noise']">
          <admst:value-to select="$lhs/setinnoise" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='final_step']">
          <admst:value-to select="$lhs/setinfinal" string="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="$lhs/setinevaluate" string="yes"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="globalassignment" path="."/>
      <admst:apply-templates select="rhs" match="e:dependency"/>
      <admst:variable name="globalassignment"/>
      <admst:push into="$lhs/variable" select="rhs/variable" onduplicate="ignore"/>
      <admst:value-to test="rhs/variable[TemperatureDependent='yes']" select="$lhs/TemperatureDependent" string="yes"/>
      <!--
        d=rhs.d,d=(c and D)?np
        l(l,r,$globalopdependent)
        $globalopdependent='no'  $globalopdependent='yes'
        c  np l  nl               np np l  nl
        np np l  nl               np np l  nl
        l  l  l  nl               l  l  l  nl
        nl nl nl nl               nl nl nl nl
      -->
      <admst:value-to select="dependency" path="rhs/dependency"/>
      <admst:choose>
        <admst:when test="[$lhs/prototype/dependency='nonlinear' or rhs/dependency='nonlinear']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[$lhs/prototype/dependency='linear' or rhs/dependency='linear']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="linear"/>
        </admst:when>
        <admst:when test="[$globalopdependent='yes' or $lhs/prototype/dependency='noprobe' or rhs/dependency='noprobe']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>      
      <admst:push into="$lhs/probe" select="rhs/probe" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:reverse select="item|variable"/>
      <admst:variable name="forcepartitionning" string="yes"/>
      <admst:choose>
        <admst:when test="[name='initial_model']">
          <admst:variable name="globalpartitionning" string="initial_model"/>
        </admst:when>
        <admst:when test="[name='initial_instance']">
          <admst:variable name="globalpartitionning" string="initial_instance"/>
        </admst:when>
        <admst:when test="[name='initial_step']">
          <admst:variable name="globalpartitionning" string="initial_step"/>
        </admst:when>
        <admst:when test="[name='noise']">
          <admst:variable name="globalpartitionning" string="noise"/>
        </admst:when>
        <admst:when test="[name='final_step']">
          <admst:variable name="globalpartitionning" string="final_step"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="forcepartitionning" string="no"/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="item" match="dependency"/>
      <admst:variable test="[$forcepartitionning='yes']" name="globalpartitionning"/>
      <admst:choose>
        <admst:when test="item[dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="item[dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="item[dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="adms.implicit.xml.module">
  <admst:variable name="globalmodule" path="."/>
  <admst:reverse select="analogfunction|analogfunction/variable|node|variable
                         |instance|instance/terminal|contribution|forloop|whileloop|case|callfunction"/>
  <admst:value-to select="node[location='ground']/grounded" string="yes"/>
  <admst:for-each select="branch">
    <admst:value-to select="discipline" path="pnode/discipline"/>
    <admst:value-to select="[nnode/grounded='yes']/grounded" string="yes"/>
    <!-- FIXME: check that pnode/nnode have same discipline -->
  </admst:for-each>
  <admst:for-each select="source|probe">
    <admst:value-to select="discipline" path="branch/discipline"/>
    <admst:value-to select="[branch/grounded='yes']/grounded" string="yes"/>
  </admst:for-each>
  <admst:for-each select="instance">
    <admst:push into="module/instantiator" select=".." onduplicate="ignore"/>
    <admst:assert select="terminal" test="nodefrommodule[location='external']"
                  format="%(../instantiator).%(nodefrommodule/name): is not terminal\n"/>
    <admst:assert select="parameterset" test="parameter[input='yes']"
                  format="%(../instantiator).%(parameter/name): is not input parameter\n"/>
  </admst:for-each>
  <admst:apply-templates select="(analogfunction/tree)|(analog/code)" match="dependency"/>
  <admst:for-each select="variable">
    <admst:value-to select="[dependency!='constant']/OPdependent" string="yes"/>
    <admst:value-to select="output" path="input"/>
    <admst:for-each select="attribute">
      <admst:value-to select="[name='type' and value='instance']/../parametertype" string="instance"/>
      <admst:value-to select="[name='ask' and value='yes']/../output" string="yes"/>
      <admst:value-to select="[name='ask' and value='no']/../output" string="no"/>
    </admst:for-each>
    <admst:apply-templates select="default" match="e:dependency"/>
    <admst:value-to
       select="default[exists(tree[datatypename='mapply_unary' and name='minus' and arg1/datatypename='number' and arg1/value='1.0'])]/value"
       string="is_neg_one"/>
    <admst:value-to select="default[exists(tree[datatypename='number' and value='0.0'])]/value" string="is_zero"/>
    <admst:value-to select="default[exists(tree[datatypename='number' and value='1.0'])]/value" string="is_one"/>
    <admst:value-to select="scope"
      test="[(input='yes' and parametertype='model') or (input='no' and (setinmodel='yes' or usedinmodel='yes')
        and (setininstance='yes' or setininitial_step='yes' or setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedininstance='yes' or usedininitial_step='yes' or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))]"
      string="global_model"/>
    <admst:value-to select="scope"
      test="[(input='yes' and parametertype='instance') or
      (input='no' and setinmodel='no' and usedinmodel='no' and
        (((setininstance='yes' or usedininstance='yes') and (setininitial_step='yes' or setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedininitial_step='yes' or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setininitial_step='yes' or usedininitial_step='yes') and (setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setinevaluate='yes' or usedinevaluate='yes') and (setinnoise='yes' or setinfinal='yes'
          or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setinnoise='yes' or usedinnoise='yes') and (setinfinal='yes' or usedinfinal='yes' or output='yes'))
        or ((setinfinal='yes' or usedinfinal='yes') and output='yes')
        or (setinmodel='no' and setininstance='no' and setinevaluate='no' and setinnoise='no' and setinfinal='no' and
            usedinmodel='no' and usedininstance='no' and usedinevaluate='no' and usedinnoise='no' and usedinfinal='no' and output='yes')
      ))]"
      string="global_instance"/>
    <admst:value-to select="isstate"
      test="[input='no' and scope='global_instance' and setininitial_step='yes' and (setinevaluate='yes' or usedinevaluate='yes')]"
      string="yes"/>
  </admst:for-each>
  <admst:template match="modify">
    <admst:choose>
      <admst:when test="[datatypename='block']">
        <admst:apply-templates select="reverse(item)" match="modify"/>
        <admst:value-to test="item[#modifys=1]" select="#modifys" path="1"/>
        <admst:value-to test="item[#modifyd=1]" select="#modifyd" path="1"/>
        <admst:value-to test="item[#modifyn=1]" select="#modifyn" path="1"/>
        <admst:value-to test="item[#modifyc=1]" select="#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:apply-templates select="else|then" match="modify"/>
        <admst:value-to test="[then/#modifys=1 or else/#modifys=1]" select="#modifys|if/#modifys|if/variable/#modifys" path="1"/>
        <admst:value-to test="[then/#modifyd=1 or else/#modifyd=1]" select="#modifyd|if/#modifyd|if/variable/#modifyd" path="1"/>
        <admst:value-to test="[then/#modifyn=1 or else/#modifyn=1]" select="#modifyn|if/#modifyn|if/variable/#modifyn" path="1"/>
        <admst:value-to test="[then/#modifyc=1 or else/#modifyc=1]" select="#modifyc|if/#modifyc|if/variable/#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <admst:apply-templates select="whileblock" match="modify"/>
        <admst:value-to test="[whileblock/#modifys=1]" select="#modifys|while/#modifys|while/variable/#modifys" path="1"/>
        <admst:value-to test="[whileblock/#modifyd=1]" select="#modifyd|while/#modifyd|while/variable/#modifyd" path="1"/>
        <admst:value-to test="[whileblock/#modifyn=1]" select="#modifyn|while/#modifyn|while/variable/#modifyn" path="1"/>
        <admst:value-to test="[whileblock/#modifyc=1]" select="#modifyc|while/#modifyc|while/variable/#modifyc" path="1"/>
        <admst:apply-templates select="whileblock" match="modify"/>
      </admst:when>
      <admst:when test="[datatypename='forloop']">
        <admst:choose>
          <admst:when test="[update/lhs/datatypename='array']">
            <admst:variable name="lhs" path="update/lhs/variable"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="lhs" path="update/lhs"/>
          </admst:otherwise>
        </admst:choose>
        <admst:apply-templates select="forblock" match="modify"/>
        <admst:value-to test="[forblock/#modifys=1]" select="#modifys|(condition|update)/#modifys|(condition|update/rhs)/($lhs|variable)/#modifys" path="1"/>
        <admst:value-to test="[forblock/#modifyd=1]" select="#modifyd|(condition|update)/#modifyd|(condition|update/rhs)/($lhs|variable)/#modifyd" path="1"/>
        <admst:value-to test="[forblock/#modifyn=1]" select="#modifyn|(condition|update)/#modifyn|(condition|update/rhs)/($lhs|variable)/#modifyn" path="1"/>
        <admst:value-to test="[forblock/#modifyc=1]" select="#modifyc|(condition|update)/#modifyc|(condition|update/rhs)/($lhs|variable)/#modifyc" path="1"/>
        <admst:apply-templates select="forblock" match="modify"/>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="caseitem/code" match="modify"/>
        <admst:for-each select="caseitem">
          <admst:value-to test="[code/#modifys=1 and defaultcase='no']" select="#modifys|condition/#modifys|condition/@variable/#modifys" path="1"/>
          <admst:value-to test="[code/#modifyd=1 and defaultcase='no']" select="#modifyd|condition/#modifyd|condition/@variable/#modifyd" path="1"/>
          <admst:value-to test="[code/#modifyn=1 and defaultcase='no']" select="#modifyn|condition/#modifyn|condition/@variable/#modifyn" path="1"/>
          <admst:value-to test="[code/#modifyc=1 and defaultcase='no']" select="#modifyc|condition/#modifyc|condition/@variable/#modifyc" path="1"/>
        </admst:for-each>
        <admst:value-to test="caseitem[#modifys=1]" select="#modifys|case/@variable/#modifys" path="1"/>
        <admst:value-to test="caseitem[#modifyd=1]" select="#modifyd|case/@variable/#modifyd" path="1"/>
        <admst:value-to test="caseitem[#modifyn=1]" select="#modifyn|case/@variable/#modifyn" path="1"/>
        <admst:value-to test="caseitem[#modifyc=1]" select="#modifyc|case/@variable/#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:choose>
          <admst:when test="[lhs/datatypename='array']">
            <admst:variable name="lhs" path="lhs/variable"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="lhs" path="lhs"/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifys=1])]" select="#modifys|rhs/#modifys|rhs/variable/#modifys" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyd=1])]" select="#modifyd|rhs/#modifys|rhs/variable/#modifyd" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyn=1])]" select="#modifyn|rhs/#modifys|rhs/variable/#modifyn" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyc=1])]" select="#modifyc|rhs/#modifys|rhs/variable/#modifyc" path="1"/>
        <admst:value-to test="$lhs/ddxprobe" select="#ddxprobe" string="yes"/>
        <admst:push into="rhs/variable/ddxprobe" select="$lhs/ddxprobe" onduplicate="ignore"/>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:choose>
          <admst:when test="[#fixmedynamic=1]">
            <admst:value-to select="#modifyd|(lhs|rhs|rhs/variable)/#modifyd" path="1"/>
          </admst:when>
          <admst:when test="[#fixmeflickernoise=1]">
            <admst:value-to select="flickernoise|lhs/flickernoise" string="yes"/>
            <admst:value-to select="#modifyn|(lhs|rhs|rhs/variable)/#modifyn" path="1"/>
          </admst:when>
          <admst:when test="[#fixmewhitenoise=1]">
            <admst:value-to select="whitenoise|lhs/whitenoise" string="yes"/>
            <admst:value-to select="#modifyn|(lhs|rhs|rhs/variable)/#modifyn" path="1"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#modifys|(lhs|rhs|rhs/variable)/#modifys" path="1"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='blockvariable']">
      </admst:when>
      <admst:when test="[datatypename='nilled']"/>
      <admst:when test="[datatypename='callfunction']">
        <admst:value-to select="#modifyc|function/arguments/variable/#modifyc" path="1"/>
      </admst:when>
      <admst:otherwise><admst:fatal format="%(datatypename): case not handled\n"/></admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:apply-templates select="analog/code" match="modify"/>
  <admst:push into="@analogitems" select="assignment|assignment/rhs|contribution|contribution/rhs|block|forloop|whileloop|case|callfunction|conditional|conditional/if"/>
  <admst:value-to select="@analogitems[#modifys=1 or #modifyn=1 or #modifyc=1]/static" string="yes"/>
  <admst:value-to select="@analogitems[#modifys!=1 and #modifyn!=1 and #modifyc!=1]/dynamic" string="yes"/>

  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1])]/#modifys" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyd=1])]/#modifyd" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyn=1])]/#modifyn" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyc=1])]/#modifyc" path="1"/>

  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyd=1 or #modifyn=1])]/insource" string="yes"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyn=1 or #modifyc=1])]/static" string="yes"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyd=1])]/dynamic" string="yes"/>
  <admst:value-to select="source[#modifys=1 or #modifyn=1]/static" string="yes"/>
  <admst:value-to select="source[#modifyd=1]/dynamic" string="yes"/>

  <!-- jacobian -->
  <admst:for-each select="contribution">
    <admst:variable name="mycontribution" path="."/>
    <admst:variable name="mysource" path="lhs"/>
    <admst:push into="$mysource/attribute" select="attribute"/>
    <!-- case I() <+ .V(). -->
    <admst:for-each select="rhs/probe[(nature=discipline/potential)and($mysource/nature=$mysource/discipline/flow)]">
      <admst:new datatype="jacobian" inputs="module,$mysource/branch/pnode,branch/pnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
      </admst:new>
      <admst:new test="branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/pnode,branch/nnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
      </admst:new>
      <admst:new test="$mysource/branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/nnode,branch/pnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
        <admst:new test="../branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/nnode,../branch/nnode">
          <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
        </admst:new>
      </admst:new>
      <admst:for-each select="/reverse(@jacobian)">
        <admst:choose>
          <admst:when test="module/jacobian[row=../../row and column=../../column]">
            <admst:variable name="jacobian" path="module/jacobian[row=../../row and column=../../column]"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="jacobian" path="."/>
            <admst:value-to select="[row=column]/diagonal" string="yes"/>
            <admst:push into="module/jacobian" select="."/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="$mycontribution[dynamic='yes']" select="$jacobian/dynamic" string="yes"/>
        <admst:value-to test="$mycontribution[dynamic='no']" select="$jacobian/static" string="yes"/>
      </admst:for-each>
      <admst:value-to select="/@jacobian"/>
    </admst:for-each>
  </admst:for-each>
  <admst:reverse select="jacobian"/>
</admst:template>

<admst:template match="adms.implicit.xml.nature">
  <admst:reverse select="/argv|/discipline|/nature"/>
  <admst:for-each select="/nature">
    <admst:value-to select="ddt_nature" path="/nature[name='%(../../ddt_name)']"/>
    <admst:value-to select="idt_nature" path="/nature[name='%(../../idt_name)']"/>
  </admst:for-each>
</admst:template>

<admst:template match="adms.implicit.xml">
  <admst:apply-templates select="." match="adms.implicit.xml.nature"/>
  <admst:apply-templates select="/module" match="adms.implicit.xml.module"/>
</admst:template>

<admst:apply-templates select="." match="adms.implicit.xml"/>

<!--admst:sendmail>
  <admst:subject>automatic mailing from %(/simulator/fullname)</admst:subject>
  <admst:arguments recipient="%(/simulator/fullname)"/>
  <admst:to recipient="r29173@freescale.com"/>
  <admst:message>
  </admst:message>
</admst:sendmail-->


</admst>

<?escript name="./qucsVersion.xml" ?>
<!--

  Copyright (C) 2006 Laurent Lemaitre <r29173@users.sourceforge.net>
  Copyright (C) 2006 Helene Parruitte <parruit@enseirb.fr>
  Copyright (C) 2006 Bertrand Ardouin <ardouin@xmodtech.com>
  Copyright (C) 2006, 2007, 2008, 2009 Stefan Jahn <stefan@lkcc.org>

  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.

-->

<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- controlling variable -->
<admst:variable name="SkipFVariable" string="n"/>

<!-- temporary variable -->
<admst:variable name="pprobe"/>
<admst:variable name="qprobe"/>
<admst:variable name="e"/>
<admst:variable name="ep"/>
<admst:variable name="eq"/>
<admst:variable name="epq"/>

<!--
* Returns the type of a variable. The returned type
* is either int, double, or char *.
-->
<admst:template match="vtype">
  <admst:choose>
    <admst:when test="[type='integer']">int</admst:when>
    <admst:when test="[type='real']">double</admst:when>
    <admst:when test="[type='string']">char*</admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- comparison, bit and logical operators -->
<admst:template match="bname">
  <admst:choose>
    <admst:when test="[name='bw_equr']">
      <admst:return name="bname" string="^~"/>
    </admst:when>
    <admst:when test="[name='bw_equl']">
      <admst:return name="bname" string="~^"/>
    </admst:when>
    <admst:when test="[name='bw_xor']">
      <admst:return name="bname" string="^"/>
    </admst:when>
    <admst:when test="[name='bw_or']">
      <admst:return name="bname" string="|"/>
    </admst:when>
    <admst:when test="[name='bw_and']">
      <admst:return name="bname" string="&amp;"/>
    </admst:when>
    <admst:when test="[name='or']">
      <admst:return name="bname" string="||"/>
    </admst:when>
    <admst:when test="[name='and']">
      <admst:return name="bname" string="&amp;&amp;"/>
    </admst:when>
    <admst:when test="[name='equ']">
      <admst:return name="bname" string="=="/>
    </admst:when>
    <admst:when test="[name='notequ']">
      <admst:return name="bname" string="!="/>
    </admst:when>
    <admst:when test="[name='lt']">
      <admst:return name="bname" string="&lt;"/>
    </admst:when>
    <admst:when test="[name='lt_equ']">
      <admst:return name="bname" string="&lt;="/>
    </admst:when>
    <admst:when test="[name='gt']">
      <admst:return name="bname" string="&gt;"/>
    </admst:when>
    <admst:when test="[name='gt_equ']">
      <admst:return name="bname" string="&gt;="/>
    </admst:when>
    <admst:when test="[name='shiftr']">
      <admst:return name="bname" string="&gt;&gt;"/>
    </admst:when>
    <admst:when test="[name='shiftl']">
      <admst:return name="bname" string="&lt;&lt;"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="variable type unknown\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- expression//function: get function name -->
<admst:template match="funcname">
  <admst:choose>
    <admst:when test="[name='abs']"><admst:return name="fname" string="fabs"/></admst:when>
    <admst:when test="[name='\$shrinkl']"><admst:return name="fname" string="shrinkl"/></admst:when>
    <admst:when test="[name='\$shrinka']"><admst:return name="fname" string="shrinka"/></admst:when>
    <admst:when test="[name='log']"><admst:return name="fname" string="log10"/></admst:when>
    <admst:when test="[name='ln']"><admst:return name="fname" string="logE"/></admst:when>
    <admst:when test="[name='limexp']"><admst:return name="fname" string="limexp"/></admst:when>
    <admst:when test="[name='\$limexp']"><admst:return name="fname" string="limexp"/></admst:when>
    <admst:otherwise><admst:return name="fname" string="%(name)"/></admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="fname">
  <admst:choose>
    <admst:when test="[name='abs']">fabs</admst:when>
    <admst:when test="[name='\$shrinkl']">shrinkl</admst:when>
    <admst:when test="[name='\$shrinka']">shrinka</admst:when>
    <admst:when test="[name='log']">log10</admst:when>
    <admst:when test="[name='ln']">logE</admst:when>
    <admst:when test="[name='limexp']">limexp</admst:when>
    <admst:when test="[name='\$limexp']">limexp</admst:when>
    <admst:otherwise>%(name)</admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="e">
  <admst:apply-templates select="." match="%(datatypename)">$e</admst:apply-templates>
</admst:template>

<admst:template match="ddx">
  <admst:apply-templates select="." match="%(datatypename)"/>
</admst:template>

<admst:template match="ddxname">
  <admst:return name="ddxname" string="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
</admst:template>

<admst:template match="dxname">
  <admst:return name="dxname" string="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
</admst:template>

<!-- variables -->
<admst:template match="variable">
  <admst:choose>
    <admst:when test="[input='yes' and parametertype='model']">
      <admst:variable name="e" path="name"/>
    </admst:when>
    <admst:when test="[input='yes' and parametertype='instance']">
      <admst:variable name="e" path="name"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_model']">
      <admst:variable name="e" path="name"/>
    </admst:when>
    <admst:when test="[input='no' and scope='global_instance']">
      <admst:variable name="e" path="name"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" path="name"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" string="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:variable name="ep" select="%(name)_%($pprobe/nature/access)%($pprobe/branch/pnode/name)_%($pprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>
  <admst:if test="$qprobe">

  <admst:variable name="eq" string="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$qprobe" list="%(probe)">
      <admst:variable name="eq" select="%(name)_%($qprobe/nature/access)%($qprobe/branch/pnode/name)_%($qprobe/branch/nnode/name)"/>
    </admst:if-inside>
  </admst:if>

  <admst:variable name="epq" string="0.0"/>
  <admst:if test="[insource='yes']">
    <admst:if-inside select="$pprobe" list="%(probe)">
      <admst:if-inside select="$qprobe" list="%(probe)">
        <admst:variable name="epq" path="ddxname(.)/[name='ddxname']/value"/>
      </admst:if-inside>
    </admst:if-inside>
  </admst:if>
  </admst:if>
</admst:template>

<!-- expression//probe -->
<admst:template match="probe">
  <admst:choose>
    <admst:when test="branch/nnode[grounded='no']">
      <admst:variable name="e" select="BP(%(branch/pnode/name),%(branch/nnode/name))"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="NP(%(branch/pnode/name))"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[.=$pprobe]">
      <admst:variable name="ep" select="1.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="ep" string="0.0"/>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:choose>
    <admst:when test="[.=$qprobe]">
      <admst:variable name="eq" select="1.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="eq" string="0.0"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="epq" string="0.0"/>
  </admst:if>
</admst:template>

<!-- expression//node -->
<admst:template match="node">
  <admst:fatal format="module node not expected here ... %(name)\n"/>

  <admst:fatal format="module node not expected here ... %(name)\n"/>
  <admst:if test="$qprobe">

  <admst:fatal format="module node not expected here ... %(name)\n"/>
  </admst:if>
</admst:template>

<!-- expression//string -->
<admst:template match="string">
  <admst:variable name="e" select="&quot;%(value)&quot;"/>

  <admst:variable name="ep" string="0.0"/>
  <admst:if test="$qprobe">

  <admst:variable name="eq" string="0.0"/>

  <admst:variable name="epq" string="0.0"/>
  </admst:if>
</admst:template>

<!-- expression//number -->
<admst:template match="number">
  <admst:choose>
    <admst:when test="[scalingunit='1']">
      <admst:variable name="e" path="value"/>
    </admst:when>
    <admst:when test="[scalingunit='E']">
      <admst:variable name="e" select="(%(value)*1.0e+18)"/>
    </admst:when>
    <admst:when test="[scalingunit='P']">
      <admst:variable name="e" select="(%(value)*1.0e+15)"/>
    </admst:when>
    <admst:when test="[scalingunit='T']">
      <admst:variable name="e" select="(%(value)*1.0e+12)"/>
    </admst:when>
    <admst:when test="[scalingunit='G']">
      <admst:variable name="e" select="(%(value)*1.0e+9)"/>
    </admst:when>
    <admst:when test="[scalingunit='M']">
      <admst:variable name="e" select="(%(value)*1.0e+6)"/>
    </admst:when>
    <admst:when test="[scalingunit='k']">
      <admst:variable name="e" select="(%(value)*1.0e+3)"/>
    </admst:when>
    <admst:when test="[scalingunit='h']">
      <admst:variable name="e" select="(%(value)*1.0e+2)"/>
    </admst:when>
    <admst:when test="[scalingunit='D']">
      <admst:variable name="e" select="(%(value)*1.0e+1)"/>
    </admst:when>
    <admst:when test="[scalingunit='d']">
      <admst:variable name="e" select="(%(value)*1.0e-1)"/>
    </admst:when>
    <admst:when test="[scalingunit='c']">
      <admst:variable name="e" select="(%(value)*1.0e-2)"/>
    </admst:when>
    <admst:when test="[scalingunit='m']">
      <admst:variable name="e" select="(%(value)*1.0e-3)"/>
    </admst:when>
    <admst:when test="[scalingunit='u']">
      <admst:variable name="e" select="(%(value)*1.0e-6)"/>
    </admst:when>
    <admst:when test="[scalingunit='n']">
      <admst:variable name="e" select="(%(value)*1.0e-9)"/>
    </admst:when>
    <admst:when test="[scalingunit='A']">
      <admst:variable name="e" select="(%(value)*1.0e-10)"/>
    </admst:when>
    <admst:when test="[scalingunit='p']">
      <admst:variable name="e" select="(%(value)*1.0e-12)"/>
    </admst:when>
    <admst:when test="[scalingunit='f']">
      <admst:variable name="e" select="(%(value)*1.0e-15)"/>
    </admst:when>
    <admst:when test="[scalingunit='a']">
      <admst:variable name="e" select="(%(value)*1.0e-18)"/>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="scaling unit not supported: %(scalingunit)\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" string="0.0"/>
  <admst:if test="$qprobe">

  <admst:variable name="eq" string="0.0"/>

  <admst:variable name="epq" string="0.0"/>
  </admst:if>
</admst:template>

<!-- unary operations -->
<admst:template match="mapply_unary">
  <admst:choose>
    <admst:when test="[name='plus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(+$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='minus']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(-$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(!$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='bw_not']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arg1" match="ddx"/>
          <admst:variable name="e" select="(~$e)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="%(name): function not handled\n"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="ep" string="0.0"/>
    </admst:when>
    <admst:when test="[$ep='0.0']">
      <admst:variable name="ep" string="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="ep" select="(+$ep)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="ep" select="(-$ep)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="ep" select="(!$ep)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="ep" select="(~$ep)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:choose>
    <admst:when test="[$e='0.0']">
      <admst:variable name="eq" string="0.0"/>
    </admst:when>
    <admst:when test="[$eq='0.0']">
      <admst:variable name="eq" string="0.0"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[name='plus']">
          <admst:variable name="eq" select="(+$eq)"/>
        </admst:when>
        <admst:when test="[name='minus']">
          <admst:variable name="eq" select="(-$eq)"/>
        </admst:when>
        <admst:when test="[name='not']">
          <admst:variable name="eq" select="(!$eq)"/>
        </admst:when>
        <admst:when test="[name='bw_not']">
          <admst:variable name="eq" select="(~$eq)"/>
        </admst:when>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="epq" string="0.0"/>
  </admst:if>
</admst:template>

<!-- binary operations -->
<admst:template match="mapply_binary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" string="$e"/>
  <admst:variable name="xp" string="$ep"/>
  <admst:variable name="xq" string="$eq"/>
  <admst:variable name="xpq" string="$epq"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" string="$e"/>
  <admst:variable name="yp" string="$ep"/>
  <admst:variable name="yq" string="$eq"/>
  <admst:variable name="ypq" string="$epq"/>
  <admst:choose>
    <admst:when test="[name='addp']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(+$y)"/>
          <admst:variable name="xp" string="0.0"/>
        </admst:when>
        <admst:when test="[arg2/math/value=0.0]">
          <admst:variable name="e" path="$x"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x+$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='addm']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)and(arg2/math/value=0.0)]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" select="(-$y)"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="$ep"/>
        </admst:when>
        <admst:when test="arg2/math[value=0.0]">
          <admst:variable name="e" string="$x"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x-$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multtime']">
      <admst:choose>
        <admst:when test="[(arg1/math/value=0.0)or(arg2/math/value=0.0)]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x*$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='multdiv']">
      <admst:choose>
        <admst:when test="[arg1/math/value=0.0]">
          <admst:variable name="e" string="0.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:when test="[(arg1/math/value=1.0)and(arg2/math/value=1.0)]">
          <admst:variable name="e" select="1.0"/>
          <admst:variable name="x" string="0.0"/>
          <admst:variable name="y" string="0.0"/>
          <admst:variable name="xp" string="0.0"/>
          <admst:variable name="yp" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="($x/$y)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="e" select="($x%(bname(.)/[name='bname']/value)$y)"/>
    </admst:otherwise>
  </admst:choose>

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" string="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" string="$yp"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" string="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="($xp+$yp)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" string="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="(-$yp)"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" string="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="($xp-$yp)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:variable name="ep" string="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" string="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='1.0']">
            <admst:variable name="ep" select="($x)"/>
          </admst:when>
          <admst:when test="[$xp='1.0' and $yp='0.0']">
            <admst:variable name="ep" select="($y)"/>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:variable name="ep" select="($x*$yp)"/>
          </admst:when>
          <admst:when test="[$yp='0.0']">
            <admst:variable name="ep" select="$xp*$y"/>
          </admst:when>
          <admst:when test="[$xp='1.0' and $yp='1.0']">
            <admst:variable name="ep" select="($x+$y)"/>
          </admst:when>
          <admst:when test="[$xp='1.0']">
            <admst:variable name="ep" select="($y+($yp*$x))"/>
          </admst:when>
          <admst:when test="[$yp='1.0']">
            <admst:variable name="ep" select="(($xp*$y)+$x)"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:variable name="ep" string="$yp"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:variable name="ep" string="$xp"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="ep" select="(($xp*$y)+($x*$yp))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:variable name="ep" string="0.0"/>
          </admst:when>
          <admst:when test="[$xp='0.0' and $yp='0.0']">
            <admst:variable name="ep" string="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(-1/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(-$yp/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xp='0.0']">
            <admst:choose>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(-$x/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(-$x*$yp/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xp='1.0']">
            <admst:choose>
              <admst:when test="[$yp='0.0']">
                <admst:variable name="ep" select="(1/$y)"/>
              </admst:when>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(($y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(($y-($x*$yp))/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:variable name="ep" string="$xp"/>
              </admst:when>
              <admst:when test="[$yp='0.0']">
                <admst:variable name="ep" select="($xp/$y)"/>
              </admst:when>
              <admst:when test="[$yp='1.0']">
                <admst:variable name="ep" select="(($xp*$y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="ep" select="(($xp*$y-$x*$yp)/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="ep" string="0.0"/>
      </admst:otherwise>
    </admst:choose>
  <admst:if test="$qprobe">

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:choose>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" string="$yq"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" string="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($xq+$yq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:choose>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="(-$yq)"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" string="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($xq-$yq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:choose>
          <admst:when test="[$x='0.0' and $y='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='1.0']">
            <admst:variable name="eq" select="($x)"/>
          </admst:when>
          <admst:when test="[$xq='1.0' and $yq='0.0']">
            <admst:variable name="eq" select="($y)"/>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:variable name="eq" select="($x*$yq)"/>
          </admst:when>
          <admst:when test="[$yq='0.0']">
            <admst:variable name="eq" select="$xq*$y"/>
          </admst:when>
          <admst:when test="[$xq='1.0' and $yq='1.0']">
            <admst:variable name="eq" select="($x+$y)"/>
          </admst:when>
          <admst:when test="[$xq='1.0']">
            <admst:variable name="eq" select="($y+($yq*$x))"/>
          </admst:when>
          <admst:when test="[$yq='1.0']">
            <admst:variable name="eq" select="(($xq*$y)+$x)"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:variable name="eq" string="$yq"/>
          </admst:when>
          <admst:when test="[$y='1.0']">
            <admst:variable name="eq" string="$xq"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="(($xq*$y)+($x*$yq))"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:choose>
          <admst:when test="[$x='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$xq='0.0' and $yq='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:when test="[$x='1.0']">
            <admst:choose>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(-1/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(-$yq/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xq='0.0']">
            <admst:choose>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(-$x/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(-$x*$yq/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:when test="[$xq='1.0']">
            <admst:choose>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" select="(1/$y)"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(($y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(($y-($x*$yq))/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:when>
          <admst:otherwise>
            <admst:choose>
              <admst:when test="[$y='1.0']">
                <admst:variable name="eq" string="$xq"/>
              </admst:when>
              <admst:when test="[$yq='0.0']">
                <admst:variable name="eq" select="($xq/$y)"/>
              </admst:when>
              <admst:when test="[$yq='1.0']">
                <admst:variable name="eq" select="(($xq*$y-$x)/$y/$y)"/>
              </admst:when>
              <admst:otherwise>
                <admst:variable name="eq" select="(($xq*$y-$x*$yq)/$y/$y)"/>
              </admst:otherwise>
            </admst:choose>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:otherwise>
        <admst:variable name="eq" string="0.0"/>
      </admst:otherwise>
    </admst:choose>

    <admst:choose>
      <admst:when test="[name='addp']">
        <admst:variable name="t1" select="+$xpq"/>
        <admst:variable name="t2" select="+$ypq"/>
        <admst:variable name="epq" select="$t1$t2"/>
        <admst:choose>
          <admst:when test="[$epq='']">
            <admst:variable name="epq" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="epq" select="($epq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='addm']">
        <admst:variable name="t1" select="+$xpq"/>
        <admst:variable name="t2" select="-$ypq"/>
        <admst:variable name="epq" select="$t1$t2"/>
        <admst:choose>
          <admst:when test="[$epq='']">
            <admst:variable name="epq" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="epq" select="($epq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multtime']">
        <admst:variable name="t1" select="+$xpq*$y"/>
        <admst:variable name="t2" select="+$xp*$yq"/>
        <admst:variable name="t3" select="+$xq*$yp"/>
        <admst:variable name="t4" select="+$x*$ypq"/>
        <admst:variable name="epq" select="$t1$t2$t3$t4"/>
        <admst:choose>
          <admst:when test="[$eq='0.0']">
            <admst:variable name="eq" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="eq" select="($eq)"/>
          </admst:otherwise>
        </admst:choose>
        <admst:choose>
          <admst:when test="[$epq='']">
            <admst:variable name="epq" string="0.0"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="epq" select="($epq)"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[name='multdiv']">
        <admst:variable name="epq" select="($xpq/$y-($xp*$yq+$xq*$yp+$x*$ypq)/$y/$y+2*$x*$yp*$yq/$y/$y/$y)"/>
      </admst:when>
    </admst:choose>
  </admst:if>
</admst:template>

<!-- ternary operations -->
<admst:template match="mapply_ternary">
  <admst:apply-templates select="arg1" match="ddx"/>
  <admst:variable name="x" string="$e"/>
  <admst:apply-templates select="arg2" match="ddx"/>
  <admst:variable name="y" string="$e"/>
  <admst:variable name="yp" string="$ep"/>
  <admst:variable name="yq" string="$eq"/>
  <admst:apply-templates select="arg3" match="ddx"/>
  <admst:variable name="z" string="$e"/>
  <admst:variable name="zp" string="$ep"/>
  <admst:variable name="zq" string="$eq"/>
  <admst:variable name="e" select="($x?$y:$z)"/>

  <admst:variable name="ep" select="($x?$yp:$zp)"/>
  <admst:if test="$qprobe">

  <admst:variable name="ep" select="($x?$yp:$zp)"/>

  <admst:variable name="epq" string="fixme"/>
  </admst:if>
</admst:template>

<!-- expression//function: mapping verilog-name == C-name of function -->
<admst:template match="function">
  <admst:choose>
    <admst:when test="[name='absdelay']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" string="$e"/>
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:variable name="xq" string="$eq"/>
      <admst:variable name="xpq" string="$epq"/>
      <admst:variable name="e" select="_DDT($x)"/>
    </admst:when>
    <admst:when test="[name='\$given' or name='\$param_given']">
      <admst:variable name="arg1" path="arguments[1]"/>
      <admst:assert test="$arg1[datatypename='variable' and input='yes']" format="%(name): argument is not a parameter\n"/>
      <admst:choose>
        <admst:when test="$arg1/[parametertype='model']">
          <admst:variable name="e" select="_param_given(&quot;%($arg1/name)&quot;)"/>
        </admst:when>
        <admst:when test="$arg1/[parametertype='instance']">
          <admst:variable name="e" select="_param_given(&quot;%($arg1/name)&quot;"/>
        </admst:when>
        <admst:otherwise>
          <admst:fatal format="%(name): should not be reached\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='\$temperature']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="_circuit_temp"/>
    </admst:when>
    <admst:when test="[name='\$mfactor']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="MFACTOR"/>
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="e" string="_vt_nom"/>   
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:apply-templates select="arguments[1]" match="ddx"/>
          <admst:variable name="x" string="$e"/>
          <admst:variable name="xp" string="$ep"/>
          <admst:variable name="xq" string="$eq"/>
          <admst:variable name="xpq" string="$epq"/>
          <admst:variable name="e" select="m00_vt($x)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="_scale"/>
    </admst:when>
    <admst:when test="[name='\$abstime']">
      <admst:assert test="[nilled(arguments)]" format="%(name): should not have arguments\n"/>
      <admst:variable name="e" string="_abstime"/>
    </admst:when>
    <admst:when test="[name='ddx']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two arguments exactly\n"/>
      <admst:assert test="arguments[2]/adms[datatypename='probe']" format="%(name): second argument is not a probe\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="not-used"/>
    </admst:when>
    <admst:when test="[name='floor']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="floor($e)"/>
    </admst:when>
    <admst:when test="[name='ceil']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="e" select="ceil($e)"/>
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="e" select="$(fname)($args)"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh']">
      <admst:assert test="arguments[count(.)=1]" format="%(name): should have one argument exactly\n"/>
      <admst:variable name="index" path="index(subexpression/expression/function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:variable name="xq" string="$eq"/>
      <admst:variable name="xpq" string="$epq"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:assert test="arguments[count(.)=2]" format="%(name): should have two argument exactly\n"/>
      <admst:variable name="index" path="index(./subexpression/expression/function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:apply-templates select="arguments[1]" match="ddx"/>
      <admst:variable name="x" string="$e"/>
      <admst:variable name="xp" string="$ep"/>
      <admst:variable name="xq" string="$eq"/>
      <admst:variable name="xpq" string="$epq"/>
      <admst:apply-templates select="arguments[2]" match="ddx"/>
      <admst:variable name="y" string="$e"/>
      <admst:variable name="yp" string="$ep"/>
      <admst:variable name="yq" string="$eq"/>
      <admst:variable name="ypq" string="$epq"/>
      <admst:variable name="e" select="d00_$(fname)$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:variable name="args" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$args!='']">
          <admst:variable name="args" select="$args,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="args" select="$args$e"/>
      </admst:for-each>
      <admst:variable name="dargs" select=""/>
      <admst:for-each select="arguments">
        <admst:if test="[$dargs!='']">
          <admst:variable name="dargs" select="$dargs,"/>
        </admst:if>
        <admst:apply-templates select="." match="ddx"/>
        <admst:variable name="dargs" select="$dargs$ep"/>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[class='builtin']">
          <admst:variable name="e" select="$(fname)($args)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="e" select="$(module)_$(fname)($args)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>

  <admst:variable name="ep" string="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given' or name='\$param_given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="ep" select="$xp*m10_vt($x)"/>
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
    </admst:when>
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx']">
    </admst:when>
    <admst:when test="[name='floor']">
    </admst:when>
    <admst:when test="[name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="ep" string="$xp"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh']">
      <admst:variable name="index" path="index(subexpression/expression/function,.)"/>
      <admst:choose>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="$xp*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" path="index(./subexpression/expression/function,.)"/>
      <admst:choose>
        <admst:when test="[$xp='0.0' and $yp='0.0']">
          <admst:variable name="ep" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="ep" select="(d11_$(fname)$index*$yp)"/>
        </admst:when>
        <admst:when test="[$yp='0.0']">
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="(d10_$(fname)$index*$xp+d11_$(fname)$index*$yp)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[class='builtin']">
          <admst:variable name="ep" select="d_$(fname)($args,$dargs)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="ep" select="$(module)_d_$(fname)($args,$dargs)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:if test="$qprobe">

  <admst:variable name="eq" string="0.0"/>
  <admst:choose>
    <admst:when test="[name='absdelay']">
    </admst:when>
    <admst:when test="[name='\$given' or name='\$param_given']">
    </admst:when>
    <admst:when test="[name='\$temperature']">
    </admst:when>
    <admst:when test="[name='\$mfactor']">
    </admst:when>
    <admst:when test="[name='\$vt']">
      <admst:choose>
        <admst:when test="[nilled(arguments)]">
          <admst:variable name="eq" string="0.0"/>
        </admst:when>
        <admst:when test="arguments[count(.)=1]">
          <admst:variable name="eq" select="$xq*m10_vt($x)"/>   
        </admst:when>
      </admst:choose>
    </admst:when>   
    <admst:when test="[name='\$scale']">
    </admst:when>
    <admst:when test="[name='\$abstime']">
    </admst:when>
    <admst:when test="[name='ddx']">
    </admst:when>
    <admst:when test="[name='floor']">
    </admst:when>
    <admst:when test="[name='ceil']">
    </admst:when>
    <admst:when test="[$SkipFVariable='y']">
    </admst:when>
    <admst:when test="[name='ddt']">
      <admst:variable name="eq" string="$xq"/>
    </admst:when>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh']">
      <admst:variable name="index" path="index(subexpression/expression/function,.)"/>
      <admst:choose>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="eq" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="eq" select="$xq*d10_$(fname)$index"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="index" path="index(./subexpression/expression/function,.)"/>
      <admst:choose>
        <admst:when test="[$xq='0.0' and $yq='0.0']">
          <admst:variable name="eq" string="0.0"/>
        </admst:when>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="eq" select="(d11_$(fname)$index*$yq)"/>
        </admst:when>
        <admst:when test="[$yq='0.0']">
          <admst:variable name="eq" select="(d10_$(fname)$index*$xq)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="eq" select="(d10_$(fname)$index*$xq+d11_$(fname)$index*$yq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="eq" select="d_$(fname)($args,$dargs)"/>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[name='abs' or name='acos' or name='asin' or name='atan' or name='cos' or name='cosh' or name='exp' or name='hypot' or name='limexp' or name='ln' or name='log' or name='sin' or name='sinh' or name='sqrt' or name='tan' or name='tanh' or name='atanh']">
      <admst:variable name="index" path="index(./subexpression/expression/function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:choose>
        <admst:when test="[$x='0.0']">
          <admst:variable name="epq" string="0.0"/>
        </admst:when>
        <admst:when test="[$xp='0.0']">
          <admst:variable name="epq" string="0.0"/>
        </admst:when>
        <admst:when test="[$xq='0.0']">
          <admst:variable name="epq" string="0.0"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="epq" select="(m20_$(fname)($x)*$xq*$xp+d10_$(fname)$index*$xpq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='pow' and $yp='0.0' and $yq='0.0']">
      <admst:choose>
        <admst:when test="[$x='0.0' or $xp='0.0' or $xq='0.0']">
          <admst:variable name="epq" string="0.0"/>
        </admst:when>
        <admst:when test="[$xpq='0.0']">
          <admst:variable name="epq" select="(m20_$(fname)($x,$y)*$xq*$xp)"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="epq" select="(m20_$(fname)($x,$y)*$xq*$xp+d10_$(fname)$index*$xpq)"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[name='div' or name='pow' or name='hypot' or name='min' or name='max']">
      <admst:variable name="epq" string="fixme"/>
      <admst:warning format="%(name): ddx dependency not implemented %(arguments[1]|' '|arguments[2])\n"/>
    </admst:when>
  </admst:choose>
  </admst:if>
</admst:template>

<!-- analog//block -->
<admst:template match="block">
  <admst:text format="{\n"/>
  <admst:apply-templates select="item" match="%(datatypename)"/>
  <admst:text format="}\n"/>
</admst:template>

<!-- analog//blockvariable -->
<admst:template match="blockvariable">
  <admst:text select="variable" format="%(vtype(.)) %(name);\n"/>
  <admst:if test="variable[insource='yes']/probe">

    <admst:for-each select="variable">
      <admst:variable name="myvariable" path="."/>
      <admst:for-each select="probe">
          <admst:variable name="pprobe" path="."/>
          <admst:variable name="ddxinsidethisprobe" string="no"/>
          <admst:if test="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidethisprobe" string="yes"/>
          </admst:if>
          <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATEFORDDX)\n"/>
          <admst:text test="[$ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
          <admst:text format="double %($myvariable/name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
          <admst:text format="#endif\n"/>
      </admst:for-each>
    </admst:for-each>

    <admst:for-each select="variable">
      <admst:variable name="myvariable" path="."/>
      <admst:new datatype="list" arguments="list of ddx probes">
        <admst:variable name="ddxprobes" path="."/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="pprobe" path="."/>
          <admst:push into="$ddxprobes/item" select="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
        </admst:for-each>
      </admst:new>
      <admst:text test="$ddxprobes/item" format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="$ddxprobes/item">
        <admst:variable name="pprobe" path="."/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="qprobe" path="."/>
          <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
        </admst:for-each>
      </admst:for-each>
      <admst:text test="$ddxprobes/item" format="#endif\n"/>
    </admst:for-each>
  </admst:if>
</admst:template>

<!-- analog//function: ddx handling -->
<admst:template match="function:precomputation">
  <admst:variable name="index" path="index(../function,.)"/>
  <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
  <admst:choose>
    <admst:when test="[name='add']">
      <admst:text format="m00_add(d00_add$index"/>
    </admst:when>
    <admst:when test="[name='div']">
      <admst:text format="m00_div(d00_div$index,d10_$(fname)$index"/>
    </admst:when>
    <admst:when test="[name='mult']">
      <admst:text format="m00_mult(d00_mult$index,d10_mult$index,d11_mult$index"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="double m00_$(fname)(d00_$(fname)$index"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text select="arguments" format=",%(e(.))"/>
  <admst:text format=")\n"/>
</admst:template>

<admst:template match="function:derivate:precomputation">
  <admst:apply-templates select="function" match="function:precomputation"/>
  <admst:if test="[hasVoltageDependentFunction='yes']">
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:text format="#if defined(_DERIVATE)\n"/>
          </admst:otherwise>
        </admst:choose>
    <admst:for-each select="function">
      <admst:variable name="index" path="index(../function,.)"/>
      <admst:variable name="fname" path="funcname(.)/[name='fname']/value"/>
      <admst:choose>
        <admst:when test="[name='exp']">
            <admst:if test="arguments/math[dependency!='constant' and dependency!='noprobe']">
              <admst:text format="#define d10_exp$index d00_exp$index\n"/>
            </admst:if>
        </admst:when>
        <admst:when test="[name='add']">
            <admst:if test="arguments/math[dependency!='constant' and dependency!='noprobe']">
              <admst:text format="#define d10_add$index 1\n"/>
              <admst:text format="#define d11_add$index 1\n"/>
            </admst:if>
        </admst:when>
        <admst:when test="[name='mult']"/>
        <admst:when test="[name='add']"/>
        <admst:when test="[name='div']">
          <admst:for-each select="arguments">
            <admst:variable name="position" path="position(.)-1"/>
            <admst:if test="math[dependency!='constant' and dependency!='noprobe']">
              <admst:text format="m1$(position)_$(fname)(d1$(position)_$(fname)$index,d00_$(fname)$index,d10_$(fname)$index"/>
              <admst:text select="../arguments" format=",%(e(.))"/>
              <admst:text format=")\n"/>
            </admst:if>
          </admst:for-each>
        </admst:when>
        <admst:otherwise>
          <admst:for-each select="arguments">
            <admst:variable name="position" path="position(.)-1"/>
            <admst:if test="math[dependency!='constant' and dependency!='noprobe']">
              <admst:text format="double m1%(position(.)-1)_$(fname)(d1%(position(.)-1)_$(fname)$index,d00_$(fname)$index"/>
              <admst:text select="../arguments" format=",%(e(.))"/>
              <admst:text format=")\n"/>
            </admst:if>
          </admst:for-each>
        </admst:otherwise>
      </admst:choose>
    </admst:for-each>
    <admst:text format="#endif\n"/>
  </admst:if>
</admst:template>

<!-- analog//assignment -->
<admst:template match="assignment">
  <admst:variable name="assignment" path="."/>
  <admst:variable name="rhs" path="rhs"/>
  <admst:variable name="lhs" path="lhs"/>
  <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  <admst:text test="rhs/function" format="{\n"/>
  <admst:variable name="ddxinsidederivate" string="no"/>
  <admst:for-each select="lhs/probe">
    <admst:variable name="pprobe" path="."/>
    <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
      <admst:variable name="ddxinsidederivate" string="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  <admst:choose>
    <admst:when test="rhs/tree/adms[datatypename='function']/..[name='ddx']">
      <admst:text format="#if defined(_DDX)\n"/>
      <admst:variable name="ddxprobe" path="rhs/tree/arguments[2]"/>
      <admst:text test="lhs[insource='yes']/probe" format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="lhs[insource='yes']/probe">
        <admst:variable name="qprobe" path="."/>
        <admst:variable name="allepq"/>
        <admst:for-each select="$lhs/probe">
          <admst:variable name="pprobe" path="."/>
          <admst:choose>
            <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
              <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(datatypename)"/>
              <admst:variable name="allepq" select="$allepq+($epq)"/>
            </admst:when>
<!--            <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/nnode]"> -->
            <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
              <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(datatypename)"/>
              <admst:variable name="allepq" select="$allepq-($epq)"/>
            </admst:when>
          </admst:choose>
        </admst:for-each>
        <admst:variable name="pprobe" path="$qprobe"/>
        <admst:text format="%(dxname($lhs)/[name='dxname']/value)=$allepq;\n"/>
      </admst:for-each>
      <admst:text test="lhs[insource='yes']/probe" format="#endif\n"/>
      <admst:variable name="allep"/>
      <admst:variable name="qprobe"/>
      <admst:for-each select="$lhs/probe">
        <admst:variable name="pprobe" path="."/>
        <admst:choose>
          <admst:when test="$pprobe/branch/pnode[.=$ddxprobe/branch/pnode]">
            <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(datatypename)"/>
            <admst:variable name="allep" select="$allep+($ep)"/>
          </admst:when>
          <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/pnode]">
<!--          <admst:when test="$pprobe/branch/nnode/[.=$ddxprobe/branch/nnode]"> -->
            <admst:apply-templates select="$rhs/tree/arguments[1]" match="%(datatypename)"/>
            <admst:variable name="allep" select="$allep-($ep)"/>
          </admst:when>
        </admst:choose>
      </admst:for-each>
      <admst:apply-templates select="lhs" match="variable"/>
      <admst:text format="$e=$allep;\n"/>
      <admst:text format="#endif\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:if test="lhs[insource='yes']">
        <admst:variable name="definedrequired" string="yes"/>
        <admst:choose>
          <admst:when test="[$ddxinsidederivate='yes']">
            <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
          </admst:when>
          <admst:when test="lhs/probe">
            <admst:text format="#if defined(_DERIVATE)\n"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="definedrequired" string="no"/>
          </admst:otherwise>
        </admst:choose>
        <admst:for-each select="lhs/probe">
          <admst:variable name="pprobe" path="."/>
          <admst:variable name="ddxinsidethisprobe" string="no"/>
          <admst:if test="$lhs/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
            <admst:variable name="ddxinsidethisprobe" string="yes"/>
          </admst:if>
          <admst:variable name="isinside" string="0"/>
          <admst:if test="$rhs/probe[.=$pprobe]">
            <admst:variable name="isinside" string="1"/>
          </admst:if>
          <admst:variable name="qprobe"/>
          <admst:variable name="ep" string="0.0"/>
          <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(datatypename)"/>
          <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" format="#if defined(_DERIVATE)\n"/>
          <admst:text format="%(dxname($lhs)/[name='dxname']/value)=$ep;\n"/>
          <admst:text test="[$ddxinsidederivate='yes' and $ddxinsidethisprobe='no']" format="#endif\n"/>
          <admst:text test="[$ddxinsidethisprobe='yes']" format="#if defined(_DERIVATE)\n"/>
          <admst:for-each select="$lhs[$ddxinsidethisprobe='yes']/probe">
            <admst:variable name="epq" string="0.0"/>
            <admst:variable name="qprobe" path="."/>
            <admst:apply-templates select="[$isinside='1']/$rhs/tree" match="%(datatypename)"/>
            <admst:text format="  %(ddxname($lhs)/[name='ddxname']/value)=$epq;\n"/>
          </admst:for-each>
          <admst:text test="$lhs[$ddxinsidethisprobe='yes']" format="#endif\n"/>
        </admst:for-each>
        <admst:text test="[$definedrequired='yes']" format="#endif\n"/>
      </admst:if>
      <admst:variable name="qprobe"/>
      <admst:apply-templates select="lhs" match="variable"/>
      <admst:text format="$e=%(e(rhs/tree));\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:text test="rhs/function" format="}\n"/>
  <admst:text test="[dynamic='yes']" format="#endif\n"/>
</admst:template>

<!-- analog//contribution[noise] -->
<admst:template match="contribution:noise">
  <admst:variable name="SkipFVariable" string="y"/>
  <admst:variable name="pnode" path="lhs/branch/pnode/name"/>
  <admst:variable name="nnode" path="lhs/branch/nnode/name"/>
  <admst:text format="_save_"/>
  <admst:if test="[whitenoise='yes']">
    <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:text format="whitenoise2($pnode,$nnode"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="whitenoise1($pnode"/>
    </admst:otherwise>
    </admst:choose>
  </admst:if>
  <admst:if test="[flickernoise='yes']">
    <admst:choose>
    <admst:when test="lhs/branch/nnode[grounded='no']">
      <admst:text format="flickernoise2($pnode,$nnode"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="flickernoise1($pnode"/>
    </admst:otherwise>
    </admst:choose>
  </admst:if>
  <admst:for-each select="rhs/tree/arguments">
    <admst:apply-templates select="." match="%(datatypename)"/>
    <admst:text format=",$e"/>
  </admst:for-each>
  <admst:if test="[flickernoise='yes']">
    <admst:if test="rhs/tree/arguments[count(.)=2]">
      <admst:text format=",NULL"/>
    </admst:if>
  </admst:if>
  <admst:if test="[whitenoise='yes']">
    <admst:if test="rhs/tree/arguments[count(.)=1]">
      <admst:text format=",NULL"/>
    </admst:if>
  </admst:if>
  <admst:text format=");\n"/>
  <admst:variable name="SkipFVariable" string="n"/>
</admst:template>

<!-- analog//contribution -->
<admst:template match="contribution">
  <admst:choose>
    <admst:when test="[whitenoise='no' and flickernoise='no']">
      <admst:apply-templates select="." match="contribution:nonoise" required="yes"/>
    </admst:when>
    <admst:otherwise>
      <admst:apply-templates select="." match="contribution:noise" required="yes"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//contribution[nonoise] -->
<admst:template match="contribution:nonoise">
  <admst:text test="[dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
  <admst:text test="rhs/function" format="{\n"/>
  <admst:apply-templates select="rhs[not(nilled(function))]" match="function:derivate:precomputation"/>
  <admst:variable name="sourcepnode" path="lhs/branch/pnode"/>
  <admst:variable name="sourcennode" path="lhs/branch/nnode"/>
  <admst:variable name="sourcepnodename" path="$sourcepnode/name"/>
  <admst:variable name="sourcennodename" path="$sourcennode/name"/>
  <admst:text format="_load_"/>
  <admst:choose>
    <admst:when test="[dynamic='yes']">
      <admst:variable name="jname" string="dQ_dV"/>
      <admst:variable name="lname" string="dynamic"/>
      <admst:text format="$(lname)_"/>
      <admst:choose>
        <admst:when test="$sourcennode[grounded='no']">
          <admst:text format="residual2($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="residual1($sourcepnodename,%(e(rhs/tree)));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:otherwise>
      <admst:variable name="jname" string="dI_dV"/>
      <admst:variable name="lname" string="static"/>
      <admst:text format="$(lname)_"/>
      <admst:choose>
        <admst:when test="$sourcennode[grounded='no']">
          <admst:text format="residual2($sourcepnodename,$sourcennodename,%(e(rhs/tree)));\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="residual1($sourcepnodename,%(e(rhs/tree)));\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
  <admst:text format="#if defined(_DERIVATE)\n"/>
  <admst:for-each select="rhs/probe">
    <admst:variable name="probepnode" path="branch/pnode"/>
    <admst:variable name="probennode" path="branch/nnode"/>
    <admst:variable name="probepnodename" path="$probepnode/name"/>
    <admst:variable name="probennodename" path="$probennode/name"/>
    <admst:variable name="pprobe" path="."/>
    <admst:apply-templates select="../tree" match="%(datatypename)"/>
    <admst:text format="_load_"/>
    <admst:text format="$(lname)_"/>
    <admst:choose>
      <admst:when test="$probennode[grounded='no']">
        <admst:if test="$sourcennode[grounded='no']">
          <admst:text format="jacobian4($sourcepnodename,$sourcennodename,$probepnodename,$probennodename,$ep);\n"/>
        </admst:if>
        <admst:if test="$sourcennode[grounded='yes']">
          <admst:text format="jacobian2p($sourcepnodename,$probepnodename,$probennodename,$ep);\n"/>
        </admst:if>
      </admst:when>
      <admst:otherwise>
        <admst:if test="$sourcennode[grounded='no']">
          <admst:text format="jacobian2s($sourcepnodename,$sourcennodename,$probepnodename,$ep);\n"/>
        </admst:if>
        <admst:if test="$sourcennode[grounded='yes']">
          <admst:text format="jacobian1($sourcepnodename,$probepnodename,$ep);\n"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
  <admst:text format="#endif\n"/>
  <admst:text test="rhs/function" format="}\n"/>
  <admst:text select="[dynamic='yes']" format="#endif\n"/>
</admst:template>

<!-- analog//conditional -->
<admst:template match="conditional">
  <admst:text select="if[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:text test="if/function" format="{\n"/>
  <admst:apply-templates select="if/function" match="function:precomputation"/>
  <admst:text format="if\n(%(e(if/tree)))\n"/>
  <admst:text select="then/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="then" match="%(datatypename)"/>
  <admst:text select="then/adms[datatypename!='block']" format="}\n"/>
  <admst:if test="else">
    <admst:text format="else\n"/>
    <admst:text test="else/adms[datatypename!='block']" format="{\n"/>
    <admst:apply-templates select="else" match="%(datatypename)"/>
    <admst:text test="else/adms[datatypename!='block']" format="}\n"/>
  </admst:if>
  <admst:text test="if/function" format="}\n"/>
  <admst:text select="if[dynamic='yes']" format="#endif /* if (...) */\n"/>
</admst:template>

<!-- analog//nilled -->
<admst:template match="nilled">
</admst:template>

<!-- analog//whileloop -->
<admst:template match="whileloop">
  <admst:text select="while[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:variable name="SkipFVariable" string="y"/>
  <admst:text format="while\n(%(e(while/tree)))\n"/>
  <admst:variable name="SkipFVariable" string="n"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="whileblock" match="%(datatypename)"/>
  <admst:text select="whileblock/adms[datatypename!='block']" format="}\n"/>
  <admst:text select="while[dynamic='yes']" format="#endif /*&lt;/dynamic_while&gt;*/\n"/>
</admst:template>

<!-- analog//forloop -->
<admst:template match="forloop">
  <admst:text select="condition[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:variable name="SkipFVariable" string="y"/>
  <admst:text format="for\n("/>
  <admst:text format="%(e(initial/lhs/tree))=%(e(initial/rhs/tree));"/>
  <admst:text format="%(e(condition/tree));"/>
  <admst:text format="%(e(update/lhs/tree))=%(e(update/rhs/tree))"/>
  <admst:text format=")\n"/>
  <admst:variable name="SkipFVariable" string="n"/>
  <admst:text select="forblock/adms[datatypename!='block']" format="{\n"/>
  <admst:apply-templates select="forblock" match="%(datatypename)"/>
  <admst:text select="forblock/adms[datatypename!='block']" format="}\n"/>
  <admst:text select="condition[dynamic='yes']" format="#endif /*&lt;/dynamic_for&gt;*/\n"/>
</admst:template>

<!-- analog//case -->
<admst:template match="case">
  <admst:text select="case[dynamic='yes']" format="#ifdef _DYNAMIC\n"/>
  <admst:variable name="casecondition" path="case/tree"/>
  <admst:variable name="havedefault" string="no"/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='yes']">
      <admst:variable name="havedefault" string="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='no']">
      <admst:text format="if\n("/>
      <admst:join select="condition" separator="||">
        <admst:apply-templates select="." match="%(datatypename)"/>
	<admst:text format="($casecondition)==($e)"/>
      </admst:join>
      <admst:text format=")\n"/>
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
      <admst:text format="else\n"/>
    </admst:if>
  </admst:for-each>
  <admst:text select="[$havedefault='no']" format="{ /* no default */ }\n"/>
  <admst:for-each select="caseitem">
    <admst:if test="[defaultcase='yes']">
      <admst:apply-templates select="code" match="%(datatypename)" required="yes"/>
    </admst:if>
  </admst:for-each>
  <admst:text select="case[dynamic='yes']" format="#endif /*&lt;/dynamic_case&gt;*/\n"/>
</admst:template>

<!-- analog//callfunctions -->
<admst:template match="callfunction">
  <admst:choose>
    <admst:when test="function[name='\$strobe']">
      <admst:text format="logprint(LOG_ERROR"/>
      <admst:for-each select="function/arguments">
      <admst:text format=",%(e(tree))"/>
      </admst:for-each>
      <admst:text format=");\n"/>
      <admst:text format="logprint(LOG_ERROR,&quot;\\n&quot;);\n"/>
    </admst:when>
    <admst:when test="function[name='\$finish']">
      <admst:text format="exit("/>
      <admst:join select="function/arguments" separator=",">
      <admst:text format="%(e(tree))"/>
      </admst:join>
      <admst:text format=");\n"/>
    </admst:when>
    <admst:otherwise>
      <admst:text format="%(function/name): not supported by this interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- save all variables used for local declaration -->
<admst:variable name="ddxinsidederivate" string="no"/>


<!-- variable declaration -->
<admst:template match="variable:declaration">
  <admst:variable name="myvariable" path="."/>
  <admst:new datatype="list" arguments="list of ddx probes">
    <admst:variable name="ddxprobes" path="."/>
    <admst:for-each select="$myvariable/probe">
      <admst:variable name="pprobe" path="."/>
      <admst:push into="$ddxprobes/item" select="$myvariable/ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]/$pprobe" onduplicate="ignore"/>
    </admst:for-each>
  </admst:new>
  <admst:if test="block/adms[datatypename='module']">
    <admst:text test="[static='no' and dynamic='yes']" format="#if defined(_DYNAMIC)\n"/>
    <admst:text test="[scope='local']" format="%(vtype(.)) %(name);\n"/>
    <admst:if test="[insource='yes']/probe">
      <admst:variable name="ddxinsidederivate" string="no"/>
      <admst:for-each select="probe">
        <admst:variable name="pprobe" path="."/>
        <admst:if test="../ddxprobe/branch/pnode[.=$pprobe/branch/pnode or .=$pprobe/branch/nnode]">
          <admst:variable name="ddxinsidederivate" string="yes"/>
        </admst:if>
      </admst:for-each>
      <admst:choose>
        <admst:when test="[$ddxinsidederivate='yes']">
          <admst:text format="#if defined(_DERIVATEFORDDX)\n"/>
        </admst:when>
        <admst:otherwise>
          <admst:text format="#if defined(_DERIVATE)\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:text select="probe" format="double %(../name)_%(nature/access)%(branch/pnode/name)_%(branch/nnode/name);\n"/>
      <admst:text test="[$ddxinsidederivate='yes']" format="#if defined(_DERIVATE)\n"/>
      <admst:for-each select="$ddxprobes/item">
        <admst:variable name="pprobe" path="."/>
        <admst:for-each select="$myvariable/probe">
          <admst:variable name="qprobe" path="."/>
          <admst:text format="  double %(ddxname($myvariable)/[name='ddxname']/value);\n"/>
        </admst:for-each>
      </admst:for-each>
      <admst:text test="[$ddxinsidederivate='yes']" format="#endif\n"/>
      <admst:text format="#endif\n"/>
    </admst:if>
    <admst:text test="[static='no' and dynamic='yes']" format="#endif\n"/>
  </admst:if>
</admst:template>

<!-- block local variable declaration -->
<admst:template match="block:local:declaration">
  <admst:choose>
    <admst:when test="adms[datatypename='assignment']">
      <admst:push into="module/evaluation/variable" select="lhs" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="adms[datatypename='block']">
      <admst:apply-templates select="item" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='conditional']">
      <admst:apply-templates select="then" match="block:local:declaration"/>
      <admst:apply-templates select="else" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="initial" match="block:local:declaration"/>
      <admst:apply-templates select="forblock" match="block:local:declaration"/>
      <admst:apply-templates select="update" match="block:local:declaration"/>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:when test="adms[datatypename='case']">
      <admst:for-each select="caseitem">
        <admst:apply-templates select="code" match="block:local:declaration"/>
      </admst:for-each>
    </admst:when>
    <admst:otherwise>
      <admst:fatal format="'datatypename=%(datatypename)': should not be reached\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- analog//code -->
<admst:template match="analog:evaluate">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name!='initial_model' and name!='initial_instance' and name!='noise' and name!='initial_step' and name!='final_step']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
    <admst:if test="adms[datatypename!='block']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:choose>
      <admst:when test="adms[datatypename!='block']">
        <admst:apply-templates select="." match="%(datatypename)"/>
      </admst:when>
      <admst:otherwise>
        <admst:if test="[name!='initial_model' and name!='initial_instance' and name!='noise' and name!='initial_step' and name!='final_step']">
          <admst:apply-templates select="." match="block"/>
        </admst:if>
      </admst:otherwise>
    </admst:choose>
  </admst:for-each>
</admst:template>

<!-- analog//[noise] -->
<admst:template match="analog:noise">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='noise']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='noise']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!-- analog//[initial_model] -->
<admst:template match="analog:initial_model">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_model']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_model']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!-- analog//[initial_instance] -->
<admst:template match="analog:initial_instance">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_instance']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!-- analog//[initial_step] -->
<admst:template match="analog:initial_step">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_step']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='initial_step']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!-- analog//[final_step] -->
<admst:template match="analog:final_step">
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='final_step']">
      <admst:apply-templates select="." match="block:local:declaration"/>
    </admst:if>
  </admst:for-each>
  <admst:apply-templates select="module/evaluation/variable" match="variable:declaration"/>
  <admst:reset select="module/evaluation/variable"/>
  <admst:for-each select="item">
    <admst:if test="adms[datatypename='block']/..[name='final_step']">
      <admst:apply-templates select="." match="block"/>
    </admst:if>
  </admst:for-each>
</admst:template>

<!--
* This template returns the description of an instance or 
* a model parameter. It works for both formats of :
*   `ATTR(info="description"  ...)
* or
*   `ATTR(desc="description"  ...)
-->
<admst:template match="variable:desc">
  <admst:choose>
    <admst:when test="attribute[name='desc' or name='info']">
      <admst:return name="variable:desc" string="&quot;%(attribute[name='desc' or name='info']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:desc" string="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
* This template returns the unit of an instance or 
* a model parameter as given in the VA file.
-->
<admst:template match="variable:unit">
  <admst:choose>
    <admst:when test="attribute[name='unit']">
      <admst:return name="variable:unit" string="&quot;%(attribute[name='unit']/value)&quot;"/>
    </admst:when>
    <admst:otherwise>
      <admst:return name="variable:unit" string="NULL"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="c:math_h">
#define m00_hypot(v00,x,y)      v00 = xhypot(x,y);
#define m10_hypot(v10,v00,x,y)  v10 = (x)/(v00);
#define m11_hypot(v11,v00,x,y)  v11 = (y)/(v00);
#define m00_max(v00,x,y)        v00 = ((x)&gt;(y))?(x):(y);
#define m10_max(v10,v00,x,y)    v10 = ((x)&gt;(y))?1.0:0.0;
#define m11_max(v11,v00,x,y)    v11 = ((x)&gt;(y))?0.0:1.0;
#define m00_min(v00,x,y)        v00 = ((x)&lt;(y))?(x):(y);
#define m10_min(v10,v00,x,y)    v10 = ((x)&lt;(y))?1.0:0.0;
#define m11_min(v11,v00,x,y)    v11 = ((x)&lt;(y))?0.0:1.0;
#define m00_pow(v00,x,y)        v00 = pow(x,y);
#define m10_pow(v10,v00,x,y)    v10 = (x==0.0)?0.0:(v00)*(y)/(x);
#define m11_pow(v11,v00,x,y)    v11 = (x==0.0)?0.0:(log(x)*(v00));

#define m00_div(v00,v10,x,y)    double v10=1/(y); double v00=(x)*v10;
#define m10_div(v10,v00,vv,x,y)
#define m11_div(v11,v00,vv,x,y) double v11 = -v00*vv;

#define m00_mult(v00,v10,v11,x,y) double v10=(x); double v11=(y); double v00=v10*v11;
#define m00_add(v00,x,y)        double v00=(x)+(y);

#define m00_cos(v00,x)          v00 = cos(x);
#define m10_cos(v10,v00,x)      v10 = (-sin(x));
#define m00_sin(v00,x)          v00 = sin(x);
#define m10_sin(v10,v00,x)      v10 = (cos(x));
#define m00_tan(v00,x)          v00 = tan(x);
#define m10_tan(v10,v00,x)      v10 = (1.0/cos(x)/cos(x));
#define m00_cosh(v00,x)         v00 = cosh(x);
#define m10_cosh(v10,v00,x)     v10 = (sinh(x));
#define m00_sinh(v00,x)         v00 = sinh(x);
#define m10_sinh(v10,v00,x)     v10 = (cosh(x));
#define m00_tanh(v00,x)         v00 = tanh(x);
#define m10_tanh(v10,v00,x)     v10 = (1.0/cosh(x)/cosh(x));
#define m00_acos(v00,x)         v00 = acos(x);
#define m10_acos(v10,v00,x)     v10 = (-1.0/sqrt(1-x*x));
#define m00_asin(v00,x)         v00 = asin(x);
#define m10_asin(v10,v00,x)     v10 = (+1.0/sqrt(1-x*x));
#define m00_atan(v00,x)         v00 = atan(x);
#define m10_atan(v10,v00,x)     v10 = (+1.0/(1+x*x));
#define m00_atanh(v00,x)        v00 = atanh(x);
#define m10_atanh(v10,v00,x)    v10 = (+1.0/(1-x*x));
#define m00_logE(v00,x)         v00 = log(x);
#define m10_logE(v10,v00,x)     v10 = (1.0/x);
#define m00_log10(v00,x)        v00 = log10(x);
#define m10_log10(v10,v00,x)    v10 = (1.0/x/M_LN10);
#define m00_sqrt(v00,x)         v00 = sqrt(x);
#define m10_sqrt(v10,v00,x)     v10 = (0.5/v00);
#define m00_fabs(v00,x)         v00 = fabs(x);
#define m10_fabs(v10,v00,x)     v10 = (((x)&gt;=0)?(+1.0):(-1.0));

#define m00_exp(v00,x)          v00 = exp(x);
#define m10_exp(v10,v00,x)      v10 = v00;

#define m00_abs(v00)            ((v00)&lt;(0)?(-(v00)):(v00))
#define m00_floor(v00,x)        v00 = floor(x);
#define m00_limexp(v00,x)       v00 = ((x)&lt;80.0?exp(x):exp(80.0)*(x-79.0));
#define m10_limexp(v10,v00,x)   v10 = ((x)&lt;80.0?(v00):exp(80.0));

#define m20_logE(v00)           (-1.0/v00/v00)
#define m20_exp(v00)            exp(v00)
#define m20_limexp(v00)         ((v00)&lt;80.0?exp(v00):0.0)
#define m20_sqrt(v00)           (-0.25/(v00)/sqrt(v00))
#define m20_fabs(v00)           0.0
#define m20_pow(x,y)            ((y)*((y)-1.0)*pow(x,y)/(x)/(x))
#define m00_vt(x)               (kBoverQ*(x))
#define m10_vt(x)               (kBoverQ)
</admst:template>

<!-- simulator settings -->
<admst:value-to select="/simulator/package_name" string="qucs"/>
<admst:value-to select="/simulator/package_tarname" string="qucs"/>
<admst:value-to select="/simulator/package_version" string="0.0.15"/>
<admst:value-to select="/simulator/package_string" string="qucs 0.0.15"/>
<admst:value-to select="/simulator/package_bugreport" string="qucs-bugs@lists.sourceforge.net"/>

<admst:for-each select="/module">
  <admst:choose>
    <admst:when test="[name='diode']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="diode"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='hic0_full']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="hicum0"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='hic2_full']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="hicum2"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='hicumL2V2p1']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="hicum2"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='hicumL2V2p23']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="hicum2"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='bjt']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="bjt"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='bjt504_va']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="mextram"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='pspva']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="psp"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='HBT_X']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="HBT_X"/>
      </admst:new>
    </admst:when>
    <admst:when test="[name='log_amp']">
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="log_amp"/>
      </admst:new>
    </admst:when>
    <admst:otherwise>
      <admst:new datatype="attribute" arguments="qucsname">
        <admst:push into="../attribute" select="." onduplicate="abort"/>
        <admst:value-to select="value" string="%(../name)"/>
      </admst:new>
    </admst:otherwise>
  </admst:choose>

  <admst:choose>
    <admst:when test="[name='r2_et_cmc' or name='r2_cmc']">
    </admst:when>
    <admst:when test="[name='mosvar']">
      <admst:if test="[nilled(variable[name='c'])]">
        <admst:new datatype="variable" inputs=".,'c',analog">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" string="scalar"/>
          <admst:value-to select="type" string="integer"/>
          <admst:value-to select="input" string="yes"/>
          <admst:value-to select="output" string="yes"/>
          <admst:value-to select="parametertype" string="model"/>
          <admst:value-to select="scope" string="global_model"/>
          <admst:new datatype="number" inputs="1">
            <admst:value-to select="scalingunit" string="1"/>
            <admst:new datatype="expression" inputs="../module,.">
              <admst:value-to select="../../default" path="."/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
    </admst:when>
    <admst:when test="[name='juncap2']">
      <admst:if test="[nilled(variable[name='d'])]">
        <admst:new datatype="variable" inputs=".,'d',analog">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" string="scalar"/>
          <admst:value-to select="type" string="integer"/>
          <admst:value-to select="input" string="yes"/>
          <admst:value-to select="output" string="yes"/>
          <admst:value-to select="parametertype" string="model"/>
          <admst:value-to select="scope" string="global_model"/>
          <admst:new datatype="number" inputs="1">
            <admst:value-to select="scalingunit" string="1"/>
            <admst:new datatype="expression" inputs="../module,.">
              <admst:value-to select="../../default" path="."/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
    </admst:when>
    <admst:when test="[name='diode']">
    </admst:when>
    <admst:when test="[name='HBT_X']">
    </admst:when>
    <admst:when test="[name='mosfetbsim4']">
    </admst:when>
    <admst:when test="[name='mod_amp']">
    </admst:when>
    <admst:when test="[name='log_amp']">
    </admst:when>
    <admst:when test="[name='hicumL2V2p23']">
    </admst:when>
    <admst:when test="[name='hicumL2V2p1']">
    </admst:when>
    <admst:when test="[name='hic2_full']">
    </admst:when>
    <admst:when test="[name='vbic' or name='bjt' or name='hic0_full' or name='hicumL0V1p2' or name='bjt504_va']">
      <admst:if test="[nilled(variable[name='npn'])]">
        <admst:new datatype="variable" inputs=".,'npn',analog">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" string="scalar"/>
          <admst:value-to select="type" string="integer"/>
          <admst:value-to select="input" string="yes"/>
          <admst:value-to select="output" string="yes"/>
          <admst:value-to select="parametertype" string="model"/>
          <admst:value-to select="scope" string="global_model"/>
          <admst:new datatype="number" inputs="1">
            <admst:value-to select="scalingunit" string="1"/>
            <admst:new datatype="expression" inputs="../module,.">
              <admst:value-to select="../../default" path="."/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
      <admst:if test="[nilled(variable[name='pnp'])]">
        <admst:new datatype="variable" inputs=".,'pnp',analog">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" string="scalar"/>
          <admst:value-to select="type" string="integer"/>
          <admst:value-to select="input" string="yes"/>
          <admst:value-to select="output" string="yes"/>
          <admst:value-to select="parametertype" string="model"/>
          <admst:value-to select="scope" string="global_model"/>
          <admst:new datatype="number" inputs="0">
            <admst:value-to select="scalingunit" string="1"/>
            <admst:new datatype="expression" inputs="../module,.">
              <admst:value-to select="../../default" path="."/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
    </admst:when>
    <admst:when test="[name='pspva' or name='EKV26MOS']">
      <admst:if test="[nilled(variable[name='nmos'])]">
        <admst:new datatype="variable" inputs=".,'nmos',analog">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" string="scalar"/>
          <admst:value-to select="type" string="integer"/>
          <admst:value-to select="input" string="yes"/>
          <admst:value-to select="output" string="yes"/>
          <admst:value-to select="parametertype" string="model"/>
          <admst:value-to select="scope" string="global_model"/>
          <admst:new datatype="number" inputs="1">
            <admst:value-to select="scalingunit" string="1"/>
            <admst:new datatype="expression" inputs="../module,.">
              <admst:value-to select="../../default" path="."/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
      <admst:if test="[nilled(variable[name='pmos'])]">
        <admst:new datatype="variable" inputs=".,'pmos',analog">
          <admst:push into="module/variable" select="." onduplicate="ignore"/>
          <admst:value-to select="sizetype" string="scalar"/>
          <admst:value-to select="type" string="integer"/>
          <admst:value-to select="input" string="yes"/>
          <admst:value-to select="output" string="yes"/>
          <admst:value-to select="parametertype" string="model"/>
          <admst:value-to select="scope" string="global_model"/>
          <admst:new datatype="number" inputs="1">
            <admst:value-to select="scalingunit" string="1"/>
            <admst:new datatype="expression" inputs="../module,.">
              <admst:value-to select="../../default" path="."/>
            </admst:new>
          </admst:new>
        </admst:new>
      </admst:if>
    </admst:when>

    <admst:otherwise>
      <admst:warning format="%(name): device not handled by the adms qucs interface\n"/>
      <admst:warning format="please ensure extra code to be added to the interface\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:for-each>

</admst>

<?escript name="./qucsMODULEcore.xml" ?>
<!--

  Copyright (C) 2006 Helene Parruitte <parruit@enseirb.fr>
  Copyright (C) 2006 Bertrand Ardouin <ardouin@xmodtech.com>
  Copyright (C) 2006, 2007, 2008 Stefan Jahn <stefan@lkcc.org>

  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.

-->

<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- handling of device: starting point -->
<admst:for-each select="/module">
<!-- definition of variables -->
<admst:value-of select="name"/>
<admst:variable name="module" select="%s"/>
<admst:count select="node[name!='GND']"/>
<admst:variable name="nbr_nodes" select="%s"/>
<admst:count select="source[whitenoise='yes']"/>
<admst:variable name="nbr_sources_whitenoise" select="%s"/>
<admst:count select="source[flickernoise='yes']"/>
<admst:variable name="nbr_sources_flickernoise" select="%s"/>
</admst:for-each>

<admst:open file="$module.core.cpp">/*
 * $(module).core.cpp - device implementations for $(module) module
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 */

<admst:for-each select="/module">
#if HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif

#include &quot;$(module).analogfunction.h&quot;
#include "component.h"
#include "device.h"
#include &quot;$(module).core.h&quot;

#ifndef CIR_$(module)
#define CIR_$(module) -1
#endif

<admst:text format="\n// external nodes\n"/>
<admst:for-each select="node">
  <admst:if test="[location='external' and name!='GND']">
  <admst:value-of select="name"/>
  <admst:text format="#define %s"/>
  <admst:value-of select="position(.)-2"/>
  <admst:text format=" %s\n"/>
  </admst:if> 
</admst:for-each>
<admst:text format="// internal nodes\n"/>
<admst:for-each select="node"> 
  <admst:if test="[location='internal' and name!='GND']">
  <admst:value-of select="name"/>
  <admst:text format="#define %s"/>
  <admst:value-of select="position(.)-2"/>
  <admst:text format=" %s\n"/>
  </admst:if>
</admst:for-each>

<admst:text format="\n// useful macro definitions"/>
#define NP(node) real (getV (node))
#define BP(pnode,nnode) (NP(pnode) - NP(nnode))
#define _load_static_residual2(pnode,nnode,current)\\
	_rhs[pnode] -= current;\\
	_rhs[nnode] += current;
#define _load_static_augmented_residual2(pnode,nnode,current)\\
	_rhs[pnode] -= current;\\
	_rhs[nnode] += current;
#define _load_static_residual1(node,current)\\
	_rhs[node] -= current;
#define _load_static_augmented_residual1(node,current)\\
	_rhs[node] -= current;
#define _load_static_jacobian4(pnode,nnode,vpnode,vnnode,conductance)\\
	_jstat[pnode][vpnode] += conductance;\\
	_jstat[nnode][vnnode] += conductance;\\
	_jstat[pnode][vnnode] -= conductance;\\
	_jstat[nnode][vpnode] -= conductance;\\
	if (doHB) {\\
	_ghs[pnode] += conductance * BP(vpnode,vnnode);\\
	_ghs[nnode] -= conductance * BP(vpnode,vnnode);\\
        } else {\\
	_rhs[pnode] += conductance * BP(vpnode,vnnode);\\
	_rhs[nnode] -= conductance * BP(vpnode,vnnode);\\
	}
#define _load_static_jacobian2p(node,vpnode,vnnode,conductance)\\
	_jstat[node][vpnode] += conductance;\\
	_jstat[node][vnnode] -= conductance;\\
	if (doHB) {\\
        _ghs[node] += conductance * BP(vpnode,vnnode);\\
        } else {\\
        _rhs[node] += conductance * BP(vpnode,vnnode);\\
	}
#define _load_static_jacobian2s(pnode,nnode,node,conductance)\\
	_jstat[pnode][node] += conductance;\\
	_jstat[nnode][node] -= conductance;\\
	if (doHB) {\\
	_ghs[pnode] += conductance * NP(node);\\
	_ghs[nnode] -= conductance * NP(node);\\
        } else {\\
	_rhs[pnode] += conductance * NP(node);\\
	_rhs[nnode] -= conductance * NP(node);\\
	}
#define _load_static_jacobian1(node,vnode,conductance)\\
	_jstat[node][vnode] += conductance;\\
	if (doHB) {\\
	_ghs[node] += conductance * NP(vnode);\\
        } else {\\
	_rhs[node] += conductance * NP(vnode);\\
	}
#define _load_dynamic_residual2(pnode,nnode,charge)\\
	if (doTR) _charges[pnode][nnode] += charge;\\
	if (doHB) {\\
	_qhs[pnode] -= charge;\\
	_qhs[nnode] += charge;\\
	}
#define _load_dynamic_residual1(node,charge)\\
	if (doTR) _charges[node][node] += charge;\\
	if (doHB) {\\
	_qhs[node] -= charge;\\
	}
#define _load_dynamic_jacobian4(pnode,nnode,vpnode,vnnode,capacitance)\\
	if (doAC) {\\
	_jdyna[pnode][vpnode] += capacitance;\\
	_jdyna[nnode][vnnode] += capacitance;\\
	_jdyna[pnode][vnnode] -= capacitance;\\
	_jdyna[nnode][vpnode] -= capacitance;\\
	}\\
        if (doTR) {\\
        _caps[pnode][nnode][vpnode][vnnode] += capacitance;\\
  	}\\
	if (doHB) {\\
	_chs[pnode] += capacitance * BP(vpnode,vnnode);\\
	_chs[nnode] -= capacitance * BP(vpnode,vnnode);\\
	}
#define _load_dynamic_jacobian2s(pnode,nnode,vnode,capacitance)\\
	if (doAC) {\\
	_jdyna[pnode][vnode] += capacitance;\\
	_jdyna[nnode][vnode] -= capacitance;\\
	}\\
	if (doTR) {\\
	_caps[pnode][nnode][vnode][vnode] += capacitance;\\
	}\\
	if (doHB) {\\
	_chs[pnode] += capacitance * NP(vnode);\\
	_chs[nnode] -= capacitance * NP(vnode);\\
	}
#define _load_dynamic_jacobian2p(node,vpnode,vnnode,capacitance)\\
	if (doAC) {\\
	_jdyna[node][vpnode] += capacitance;\\
        _jdyna[node][vnnode] -= capacitance;\\
        }\\
	if (doTR) {\\
        _caps[node][node][vpnode][vnnode] += capacitance;\\
	}\\
	if (doHB) {\\
	_chs[node] += capacitance * BP(vpnode,vnnode);\\
	}
#define _load_dynamic_jacobian1(node,vnode,capacitance)\\
	if (doAC) {\\
	_jdyna[node][vnode] += capacitance;\\
	}\\
	if (doTR) {\\
	_caps[node][node][vnode][vnode] += capacitance;\\
	}\\
	if (doHB) {\\
	_chs[node] += capacitance * NP(vnode);\\
	}

#define _save_whitenoise1(n1,pwr,type)\\
	_white_pwr[n1][n1] += pwr;
#define _save_whitenoise2(n1,n2,pwr,type)\\
	_white_pwr[n1][n2] += pwr;
#define _save_flickernoise1(n1,pwr,exp,type)\\
	_flicker_pwr[n1][n1] += pwr;\\
	_flicker_exp[n1][n1] += exp;
#define _save_flickernoise2(n1,n2,pwr,exp,type)\\
	_flicker_pwr[n1][n2] += pwr;\\
	_flicker_exp[n1][n2] += exp;
#define _load_whitenoise2(n1,n2,pwr)\\
	cy (n1,n2) -= pwr/kB/T0; cy (n2,n1) -= pwr/kB/T0;\\
	cy (n1,n1) += pwr/kB/T0; cy (n2,n2) += pwr/kB/T0;
#define _load_whitenoise1(n1,pwr)\\
	cy (n1,n1) += pwr/kB/T0;
#define _load_flickernoise2(n1,n2,pwr,exp)\\
	cy (n1,n2) -= pwr*pow(_freq,-exp)/kB/T0;\\
	cy (n2,n1) -= pwr*pow(_freq,-exp)/kB/T0;\\
	cy (n1,n1) += pwr*pow(_freq,-exp)/kB/T0;\\
	cy (n2,n2) += pwr*pow(_freq,-exp)/kB/T0;
#define _load_flickernoise1(n1,pwr,exp)\\
	cy (n1,n1) += pwr*pow(_freq,-exp)/kB/T0;

<admst:text format="\n// derivative helper macros"/>
<admst:apply-templates select="." match="c:math_h"/>

<admst:text format="\n\n// simulator specific definitions"/>
#define _modelname              &quot;$(module)&quot;
#define _instancename           getName()
#define _circuit_temp	        (getPropertyDouble(&quot;Temp&quot;)+273.15)
#define _param_given(p)		(isPropertyGiven(p)?1:0)

<admst:text format="\n\n// \$vt and \$vt() functions "/>
#define _vt_nom                 (kBoverQ*_circuit_temp)

using namespace device;

<!-- ---------------------------------------------------------------------- -->

<admst:text format="\n/* Device constructor. */\n"/>
<admst:text format="$module::$module() : circuit ($nbr_nodes)\n{\n"/>
<admst:text format="  type = CIR_$module;\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of model. */\n"/>
<admst:text format="void $module::initModel (void)\n{\n"/>
<admst:text format="  // create internal nodes\n"/>
<admst:for-each select="node">
  <admst:if test="[location='internal' and name!='GND']">
  <admst:value-of select="name"/>
  <admst:value-of select="name"/>  
  <admst:text format="  setInternalNode (%s, &quot;%s&quot;);\n"/>
  </admst:if>
</admst:for-each>
  // get device model parameters
  loadVariables ();
  // evaluate global model equations
  initializeModel ();
  // evaluate initial step equations
  initialStep ();
  // evaluate global instance equations
  initializeInstance ();
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of DC analysis. */\n"/>
<admst:text format="void $module::initDC (void)\n{"/>
  allocMatrixMNA ();
  initModel ();
  pol = 1;
  restartDC ();
  doAC = 1;
  doTR = 0;
  doHB = 0;
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Run when DC is restarted (fallback algorithms). */\n"/>
<admst:text format="void $module::restartDC (void)\n{\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialize Verilog-AMS code. */\n"/>
<admst:text format="void $module::initVerilog (void)\n{\n"/>
		
<admst:text format="  // initialization of noise variables\n"/>
<admst:for-each select="source[whitenoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  _white_pwr[$pnode][$nnode] = 0.0;\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  _white_pwr[$pnode][$pnode] = 0.0;\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:for-each select="source[flickernoise='yes']">
  <admst:value-of select="branch/nnode/name" />
  <admst:value-of select="branch/pnode/name" />
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  _flicker_pwr[$pnode][$nnode] = 0.0;\n" />
    <admst:text format="  _flicker_exp[$pnode][$nnode] = 0.0;\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  _flicker_pwr[$pnode][$pnode] = 0.0;\n" />
    <admst:text format="  _flicker_exp[$pnode][$pnode] = 0.0;\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
  int i1, i2, i3, i4;

  // zero charges
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="    _charges[i1][i2] = 0.0;\n"/>
<admst:text format="  } }\n"/>
  // zero capacitances
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="  for (i4 = 0; i4 < $nbr_nodes; i4++) {\n"/>
<admst:text format="    _caps[i1][i2][i3][i4] = 0.0;\n"/>
<admst:text format="  } } } }\n"/>
  // zero right hand side, static and dynamic jacobian
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    _rhs[i1] = 0.0;\n"/>
<admst:text format="    _qhs[i1] = 0.0;\n"/>
<admst:text format="    _chs[i1] = 0.0;\n"/>
<admst:text format="    _ghs[i1] = 0.0;\n"/>
<admst:text format="    for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      _jstat[i1][i2] = 0.0;\n"/>
<admst:text format="      _jdyna[i1][i2] = 0.0;\n"/>
<admst:text format="    }\n  }\n"/>

<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Load device model input parameters. */\n"/>
<admst:text format="void $module::loadVariables (void)\n{\n"/>
<admst:for-each select="variable">
  <admst:if test="[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>
    <admst:choose>
    <admst:when test="[type='real']">
    <admst:text format="  %s = getPropertyDouble (&quot;%s&quot;);\n"/> 
    </admst:when>
    <admst:when test="[type='integer']">
    <admst:text format="  %s = getPropertyInteger (&quot;%s&quot;);\n"/> 
    </admst:when>
    <admst:otherwise>
    <admst:text format="  %s = getPropertyString (&quot;%s&quot;);\n"/> 
    </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:for-each>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* #define's for translated code */\n"/>
<admst:text format="#undef  _DDT\n"/>
<admst:text format="#define _DDT(q) q\n"/>
<admst:text format="#define _DYNAMIC\n"/>
<admst:text format="#define _DERIVATE\n"/>
<admst:text format="#define _DDX\n"/>
<admst:text format="#define _DERIVATEFORDDX\n"/>
<admst:text format="\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Evaluate Verilog-AMS equations in model initialization. */\n"/>
<admst:text format="void $module::initializeModel (void)\n{\n"/>
<admst:apply-templates select="analog/code" match="analog:initial_model"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Evaluate Verilog-AMS equations in instance initialization. */\n"/>
<admst:text format="void $module::initializeInstance (void)\n{\n"/>
<admst:apply-templates select="analog/code" match="analog:initial_instance"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Evaluate Verilog-AMS equations in initial step. */\n"/>
<admst:text format="void $module::initialStep (void)\n{\n"/>
<admst:apply-templates select="analog/code" match="analog:initial_step"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Evaluate Verilog-AMS equations in final step. */\n"/>
<admst:text format="void $module::finalStep (void)\n{\n"/>
<admst:apply-templates select="analog/code" match="analog:final_step"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Evaluate Verilog-AMS equations in analog block. */\n"/>
<admst:text format="void $module::calcVerilog (void)\n{\n"/>
/* ----------------- evaluate verilog analog equations -------------------- */
<admst:text format="\n"/>

<admst:apply-templates select="analog/code" match="analog:evaluate"/>
/* ------------------ end of verilog analog equations --------------------- */

/* ------------------ evaluate verilog noise equations -------------------- */
<admst:text format="\n"/>
<admst:apply-templates select="analog/code" match="analog:noise"/>
/* ------------------- end of verilog noise equations --------------------- */
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform DC iteration. */\n"/>
<admst:text format="void $module::calcDC (void)\n{"/>
  // evaluate Verilog code
  initVerilog ();		
  calcVerilog ();		

  // fill right hand side and static jacobian
<admst:text format="\n"/>
<admst:text format="  for (int i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    setI (i1, _rhs[i1]);\n"/>
<admst:text format="    for (int i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      setY (i1, i2, _jstat[i1][i2]);\n"/>
<admst:text format="    }\n  }\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Save operating points. */\n"/>
<admst:text format="void $module::saveOperatingPoints (void)\n{\n"/>

<admst:text format="  // save global instance operating points"/>
<admst:for-each select="variable[scope='global_instance' and input='no']">
  setOperatingPoint (&quot;%(name)&quot;, %(name));
</admst:for-each>
<admst:text format="\n"/>
<!--
<admst:text format="#if DEBUG\n"/>

<admst:for-each select="node">
<admst:if test="[name!='GND']">
  <admst:value-of select="name"/>
  <admst:variable name="node1" select="%s"/>
    <admst:for-each select="../node">
      <admst:if test="[name!='GND']">
      <admst:value-of select="name"/>
      <admst:variable name="node2" select="%s"/>      
      <admst:text format="  setOperatingPoint (&quot;jstat[$node1][$node2]&quot;, _jstat[$node1][$node2]);\n"/>
      <admst:text format="  setOperatingPoint (&quot;jdyna[$node1][$node2]&quot;, _jdyna[$node1][$node2]);\n"/>
      </admst:if> 
    </admst:for-each>
</admst:if> 
</admst:for-each>

<admst:for-each select="source[whitenoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  setOperatingPoint (&quot;white_pwr[$pnode][$nnode]&quot;, _white_pwr[$pnode][$nnode]);\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  setOperatingPoint (&quot;white_pwr[$pnode][$pnode]&quot;, _white_pwr[$pnode][$pnode]);\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>

<admst:for-each select="source[flickernoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  setOperatingPoint (&quot;flicker_pwr[$pnode][$nnode]&quot;, _flicker_pwr[$pnode][$nnode]);\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  setOperatingPoint (&quot;flicker_pwr[$pnode][$pnode]&quot;, _flicker_pwr[$pnode][$pnode]);\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:text format="#endif /* DEBUG */\n"/>
-->
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Load operating points. */\n"/>
<admst:text format="void $module::loadOperatingPoints (void)\n{\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Calculate operating points. */\n"/>
<admst:text format="void $module::calcOperatingPoints (void)\n{\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of AC analysis. */\n"/>
<admst:text format="void $module::initAC (void)\n{"/>
  allocMatrixMNA ();
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform AC calculations. */\n"/>
<admst:text format="void $module::calcAC (nr_double_t frequency)\n{"/>
  setMatrixY (calcMatrixY (frequency));
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Compute Y-matrix for AC analysis. */\n"/>
<admst:text format="matrix $module::calcMatrixY (nr_double_t frequency)\n{"/>
  _freq = frequency;
  saveOperatingPoints ();
  matrix y ($nbr_nodes);

<admst:text format="\n"/>
<admst:text format="  for (int i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    for (int i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      y (i1,i2) = rect (_jstat[i1][i2], _jdyna[i1][i2] * 2 * M_PI * _freq);\n"/>
<admst:text format="    }\n  }\n"/>
  return y;
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of S-parameter analysis. */\n"/>
<admst:text format="void $module::initSP (void)\n{"/>
  allocMatrixS ();
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform S-parameter calculations. */\n"/>
<admst:text format="void $module::calcSP (nr_double_t frequency)\n{"/>
  setMatrixS (ytos (calcMatrixY (frequency)));   
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of transient analysis. */\n"/>
<admst:text format="void $module::initTR (void)\n{"/>
  setStates (2 * $nbr_nodes * $nbr_nodes);
  initDC ();
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform transient analysis iteration step. */\n"/>
<admst:text format="void $module::calcTR (nr_double_t)\n{"/>
  doHB = 0;
  doAC = 1;
  doTR = 1;
  calcDC ();

  int i1, i2, i3, i4, state;

  // 2-node charge integrations
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="    state = 2 * (i2 + $nbr_nodes * i1);\n"/>
<admst:text format="    if (i1 != i2)\n"/>
<admst:text format="    if (_charges[i1][i2] != 0.0)\n"/>
<admst:text format="      transientCapacitanceQ (state, i1, i2, _charges[i1][i2]);\n"/>
<admst:text format="  } }\n"/>
  // 1-node charge integrations
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    state = 2 * (i1 + $nbr_nodes * i1);\n"/>
<admst:text format="    if (_charges[i1][i1] != 0.0)\n"/>
<admst:text format="      transientCapacitanceQ (state, i1, _charges[i1][i1]);\n"/>
<admst:text format="  }\n"/>
  // charge: 2-node, voltage: 2-node
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="  if (i1 != i2)\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="  for (i4 = 0; i4 < $nbr_nodes; i4++) {\n"/>
<admst:text format="    if (i3 != i4)\n"/>
<admst:text format="    if (_caps[i1][i2][i3][i4] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC (i1, i2, i3, i4, _caps[i1][i2][i3][i4], BP(i3,i4));\n"/>
<admst:text format="  } } } }\n"/>
  // charge: 2-node, voltage: 1-node
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="  if (i1 != i2)\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="    if (_caps[i1][i2][i3][i3] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC2Q (i1, i2, i3, _caps[i1][i2][i3][i3], NP(i3));\n"/>
<admst:text format="  } } }\n"/>
  // charge: 1-node, voltage: 2-node
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="  for (i4 = 0; i4 < $nbr_nodes; i4++) {\n"/>
<admst:text format="    if (i3 != i4)\n"/>
<admst:text format="    if (_caps[i1][i1][i3][i4] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC2V (i1, i3, i4, _caps[i1][i1][i3][i4], BP(i3,i4));\n"/>
<admst:text format="  } } }\n"/>     
  // charge: 1-node, voltage: 1-node
<admst:text format="\n"/>
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>               
<admst:text format="    if (_caps[i1][i1][i3][i3] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC (i1, i3, _caps[i1][i1][i3][i3], NP(i3));\n"/>
<admst:text format="  } }\n"/> 
  
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Compute Cy-matrix for AC noise analysis. */\n"/>
<admst:text format="matrix $module::calcMatrixCy (nr_double_t frequency) \n{"/>
  _freq = frequency;
  matrix cy ($nbr_nodes);

<admst:text format="\n"/>
<admst:for-each select="source[flickernoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  _load_flickernoise2 ($pnode,$nnode,_flicker_pwr[$pnode][$nnode],_flicker_exp[$pnode][$nnode]);\n"/>
  </admst:when>
  <admst:otherwise>
    <admst:text format="  _load_flickernoise1 ($pnode,_flicker_pwr[$pnode][$pnode],_flicker_exp[$pnode][$pnode]);\n"/>
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:for-each select="source[whitenoise='yes']">
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:value-of select="branch/nnode/name"/>
    <admst:value-of select="branch/pnode/name"/>
    <admst:variable name="pnode" select="%s"/>
    <admst:variable name="nnode" select="%s"/>
    <admst:text format="  _load_whitenoise2 ($pnode,$nnode,_white_pwr[$pnode][$nnode]);\n"/>
  </admst:when>
  <admst:otherwise>
    <admst:value-of select="branch/nnode/name"/>
    <admst:value-of select="branch/pnode/name"/>
    <admst:variable name="pnode" select="%s"/>
    <admst:variable name="nnode" select="%s"/>
    <admst:text format="  _load_whitenoise1 ($pnode,_white_pwr[$pnode][$pnode]);\n"/>
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:text format="\n  return cy;\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform AC noise computations. */\n"/>
<admst:text format="void $module::calcNoiseAC (nr_double_t frequency) \n{"/>
  setMatrixN (calcMatrixCy (frequency));
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform S-parameter noise computations. */\n"/>
<admst:text format="void $module::calcNoiseSP (nr_double_t frequency) \n{"/>
  setMatrixN (cytocs (calcMatrixCy (frequency) * z0, getMatrixS ()));
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of HB analysis. */\n"/>
<admst:text format="void $module::initHB (int)\n{"/>
  initDC ();
  allocMatrixHB ();
<admst:text format="\n}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform HB analysis. */\n"/>
<admst:text format="void $module::calcHB (int)\n{"/>
  doHB = 1;
  doAC = 1;
  doTR = 0;

  // jacobian dI/dV and currents get filled
  calcDC ();
  saveOperatingPoints ();

  // fill in HB matrices
<admst:text format="\n"/>
<admst:text format="  for (int i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    setQ  (i1, _qhs[i1]); // charges\n"/>
<admst:text format="    setCV (i1, _chs[i1]); // jacobian dQ/dV * V\n"/>
<admst:text format="    setGV (i1, _ghs[i1]); // jacobian dI/dV * V\n"/>
<admst:text format="    for (int i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      setQV (i1, i2, _jdyna[i1][i2]); // jacobian dQ/dV\n"/>
<admst:text format="    }\n  }\n"/>

<admst:text format="}\n"/>
#include &quot;$(module).defs.h&quot;

</admst:for-each>

</admst:open>

<admst:open file="$module.core.h">/*
 * $(module).core.h - device class definitions for $(module) module
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 */

<admst:for-each select="/module">
#ifndef __$(module)_H__
#define __$(module)_H__

class $(module) : public circuit
{
 public:
  CREATOR ($(module));

  void initDC (void);
  void restartDC (void);
  void calcDC (void);
  void saveOperatingPoints (void);
  void loadOperatingPoints (void);
  void calcOperatingPoints (void);
  void initAC (void);
  void calcAC (nr_double_t);
  void initSP (void);
  void calcSP (nr_double_t);
  void calcNoiseAC (nr_double_t);
  void calcNoiseSP (nr_double_t);
  void initTR (void);
  void calcTR (nr_double_t);
  void initHB (int);
  void calcHB (int);
  
 private:
  void initVerilog (void);
  void calcVerilog (void);
  void initModel (void);
  void loadVariables (void);
  void initializeModel (void);
  void initializeInstance (void);
  void initialStep (void);
  void finalStep (void);
  matrix calcMatrixY (nr_double_t);
  matrix calcMatrixCy (nr_double_t);

 private:
  int doHB;
  int doAC;
  int doTR;

  nr_double_t _freq;
  nr_double_t _rhs[$nbr_nodes];
  nr_double_t _qhs[$nbr_nodes];
  nr_double_t _ghs[$nbr_nodes];
  nr_double_t _chs[$nbr_nodes];
  nr_double_t _jstat[$nbr_nodes][$nbr_nodes];
  nr_double_t _jdyna[$nbr_nodes][$nbr_nodes];
  nr_double_t _white_pwr[$nbr_nodes][$nbr_nodes];
  nr_double_t _flicker_pwr[$nbr_nodes][$nbr_nodes];
  nr_double_t _flicker_exp[$nbr_nodes][$nbr_nodes];
  nr_double_t _charges[$nbr_nodes][$nbr_nodes];
  nr_double_t _caps[$nbr_nodes][$nbr_nodes][$nbr_nodes][$nbr_nodes];

<admst:text format="\n  // device model parameters\n"/>
<admst:for-each select="variable">
  <admst:if test="[input='yes']">
    <admst:value-of select="name"/>
    <admst:choose>
    <admst:when test="[type='real']">
    <admst:text format="  nr_double_t %s;\n"/> 
    </admst:when>
    <admst:when test="[type='integer']">
    <admst:text format="  int %s;\n"/> 
    </admst:when>
    <admst:otherwise>
    <admst:text format="  char * %s;\n"/> 
    </admst:otherwise>
    </admst:choose>
  </admst:if>
</admst:for-each>

<admst:text format="\n  // global model variables"/>
<admst:for-each select="variable[scope='global_model' and input='no']">
  %(vtype(.)) %(name);
  <admst:choose>
    <admst:when test="attribute[name='info']">
      <admst:value-of select="attribute[name='info']/value"/>
	<admst:text format=" // %s"/>
    </admst:when>
    <admst:when test="attribute[name='desc']">
      <admst:value-of select="attribute[name='desc']/value"/>
	<admst:text format=" // %s"/>
    </admst:when>
  </admst:choose>
  <admst:choose>
    <admst:when test="attribute[name='unit']">
      <admst:value-of select="attribute[name='unit']/value"/>
	<admst:text format=" (%s)"/>
    </admst:when>
  </admst:choose>
</admst:for-each>
<admst:text format="\n"/>

<admst:text format="\n"/>
<admst:for-each select="variable[scope='global_instance' and input='no']">
  <admst:text format="  // "/>
  <admst:choose>
    <admst:when test="attribute[name='info']">
      <admst:value-of select="attribute[name='info']/value"/>
	<admst:text format="%s"/>
    </admst:when>
    <admst:when test="attribute[name='desc']">
      <admst:value-of select="attribute[name='desc']/value"/>
	<admst:text format="%s"/>
    </admst:when>
  </admst:choose>
  <admst:choose>
    <admst:when test="attribute[name='unit']">
      <admst:value-of select="attribute[name='unit']/value"/>
	<admst:text format=" (%s)"/>
    </admst:when>
  </admst:choose>
  <admst:text format="\n"/>
  <admst:text format="  %(vtype(.)) %(name);\n"/>
</admst:for-each>
<admst:text format="\n"/>
};

#endif /* __$(module)_H__ */

</admst:for-each>

</admst:open>

<admst:message format="$module.core.cpp and $module.core.h: files created\n"/>

</admst>
